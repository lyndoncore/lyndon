<!DOCTYPE html>
<html id="html" lang="en">
<head>
<title>Lyndon Core</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="css/main.css">
<script async src="js/dev-scripts.js"></script>
<link rel="shortcut icon" type="image/png" href="images/favicon.png"/>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-83199602-1', 'auto');
  ga('send', 'pageview');
</script>
</head>
<body data-page-name="design">

	<noscript><div class="no-js-header"></noscript>
	<header id="header" class="header">
		<a href="index.html" class="header__home">LYNDON CORE</a>
		<div id="header__titleBg" class="header__titleBg">
			<div class="header__titleBg--faux">
				<h1 class="header__title">Site Design</h1>
			</div>
		</div>
	</header>
	<noscript></div></noscript>

	<main id="main" class="main">

		<nav class="nav">
			<ul class="nav__list" id="sidebar">
				<li><a class="nav__parent" href="index.html">Home</a></li>
				<li><a class="nav__parent" href="#">Site Design</a></li>
				<li><a id="navIntro" class="nav__child" href="#intro">Intro</a></li>
				<li><a id="navToolkit" class="nav__child" href="#toolkit">Toolkit</a></li>
				<li><a id="navResponsiveness" class="nav__child" href="#responsiveness">Responsiveness</a></li>
				<li><a id="navResilience" class="nav__child" href="#resilience">Resilience</a></li>
				<li><a id="navCompression" class="nav__child" href="#compression">Compression</a></li>
				<li><a id="navDesign" class="nav__child" href="#design">Design</a></li>
				<li><a id="navCaching" class="nav__child" href="#caching">Caching</a></li>
				<li><a id="navCssOptimizations" class="nav__child" href="#cssOptimizations">CSS optimization</a></li>
				<li><a id="navImageOptimizations" class="nav__child" href="#imageOptimizations">Image optimization</a></li>
				<li><a id="navArtDirection" class="nav__child" href="#artDirection">Art direction</a></li>
				<li><a id="navInTheWorks" class="nav__child" href="#inTheWorks">In the works</a></li>
				<li><a class="nav__parent" href="resume.html">Resume</a></li>
			</ul>
		</nav>

		<article class="content">

			<h2 id="intro" class="content__heading">Intro</h2>

				<p class="content__body">Brutally simple. From conception, this site was designed to embody that attribute visually, but not so much under the hood. This deceivingly simple site is a performance pet project, and utilizes some neat technology, so it runs fast just about anywhere, on just about anything. This page's purpose is to document the design decisions that were made during the creation of this site, and the methodology behind them. I encourage you to verify and challenge these design methods before implementing them in your own projects. It has been a learning process, so if you discover any information here that is definitively incorrect/outdated, any of the links have broken, any typos, or find a bug of sorts, please <a class="content__link" href="mailto:lyndoncore@gmail.com">reach out to me</a> so it can be corrected.</p>

				<h3 class="content__title">An observation</h3>
				<p class="content__body">I think it's interesting how web industry leaders approach their personal website design. You see many of these really smart people implementing superficially simple sites (to name a few: <a class="content__link" href="https://stevesouders.com/">Steve Souders</a>, <a class="content__link" href="http://chriscoyier.net/">Chris Coyier</a>, <a class="content__link" href="https://jakearchibald.com/">Jake Archibald</a>, and <a class="content__link" href="https://www.igvita.com/">Ilya Grigorik</a>). I mean, I'm sure these guys could build/design whatever they want, but it's my guess that they probably prioritize building things that <i>work</i>. Making complex websites work, and making them sexy aren't mutually exclusive, however in our current web ecosystem, it's considerably difficult to do both, and typically takes a team. I'm no industry leader, but I've noticed a strong correlation between the more I learn about the web and how simple I want to make my site.</p>

			<h2 id="toolkit" class="content__heading">Toolkit</h2>

				<ul class="content__list">
					<li>HTML5</li>
					<li>CSS</li>
					<li>JavaScript</li>
					<li>SASS</li>
					<li>Gulp</li>
					<li>Modernizr</li>
					<li>Service Worker</li>
					<li>Git/Github</li>
					<li>Sublime Text</li>
					<li>Chrome DevTools</li>
					<li>Amazon S3</li>
					<li>Amazon Route 53</li>
					<li>Amazon CloudFront</li>
					<li>AWS Certificate Manager</li>
					<li>Photoshop CS6</li>
				</ul>
				<h3 class="content__title">Honorable Mentions:</h3>
				<ul class="content__list">
					<li><a class="content__link" href="https://www.webpagetest.org/">WebPageSpeedTest</a></li>
					<li><a class="content__link" href="http://jshint.com/">JSHint</a></li>
					<li><a class="content__link" href="https://webp-converter.com/">PNG to WEBP converter</a></li>
					<li><a class="content__link" href="http://websemantics.co.uk/online_tools/image_to_data_uri_convertor/">Image to URI converter</a></li>
					<li>CanIUse.com</li>
					<li>PageSpeed Insights</li>
					<li>Google Analytics</li>
					<li>Google's Closure Compiler</li>
					<li><a class="content__link" href="https://search.google.com/structured-data/testing-tool">Google's Structured Data Testing Tool</a></li>
					<li><a class="content__link" href="https://chrome.google.com/webstore/detail/accessibility-developer-t/fpkknkljclfencbdbgkenhalefipecmb">Google's Accessibility Developer Tools</a> - Chrome extension</li>
				</ul>

			<h2 id="responsiveness" class="content__heading">Responsiveness</h2>

				<p class="content__body">I've employed media queries, flexbox, vendor prefixes, and some other minor tweaks to ensure this site's accessibility to all users on any reasonably modern device.</p>

				<h3 id="progressiveEnhancement" class="content__title">Progressive enhancement</h3>
				<p class="content__body">It may have been somewhat clear from my little <a class="content__link" href="#intro">intro</a>, but <a class="content__link" href="http://alistapart.com/article/understandingprogressiveenhancement">progressive enhancement</a> was always a primary consideration throughout the designing process of this site. The idea is to implement a content-first strategy, where our markup can stand alone, and is <i>enhanced</i> by our CSS and Javascript, not dependant on them (try reloading this page without CSS and disabled JavaScript). A complete experience should always be the outcome for any of the readers here, independent of device capabilities. I'm not going to cover every instance of progressive enhancement on this site, however, if you think of the "why?" behind many of these topics, progressive enhancement will be your answer.</p>

				<h3 class="content__title">Mobile-first</h3>
				<p class="content__body">A content-first strategy goes hand-and-hand with a mobile-first strategy, where the most important content (our HTML) is boiled down in its most restricted environment. For this site, thinking mobile-first more literally meant wireframing ideas with mobile sized/shaped viewports prior to doing anything else. Doing this ensured a complete experience on smaller screens, as well as forcing the proper use of positive and negative visual spacing as the viewport grows into larger screens. The results were breakpoints dictated by the flow of content, and not optimized for any particular device or user-agent. These breakpoints were employed with <a class="content__link" href="https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries">CSS media queries</a>, which simply define the rules for our conditional CSS, and although simple, are very powerful components in the design of responsive websites.</p>

				<h3 class="content__title">Flexbox</h3>
				<p class="content__body">Using the <a class="content__link" href="https://www.w3.org/TR/css-flexbox-1/">CSS Flexible Box Layout Module</a>, commonly referred to as just "Flexbox", has also made designing a responsive web experience easy and intuitive. <a class="content__link" href="http://caniuse.com/#search=flexbox">Browser support for Flexbox</a> is actually pretty good with the use of vendor-prefixing, and if you haven't heard of it, or just getting around to learning it, there are a million good resources to help you learn the basics. The fluid nature of Flexbox makes designing with <code class="content__code">meta viewport</code> an easy alternative to using fixed-width elements/containers - which are susceptible to overflowing the viewport and causing potential issues like unintended horizontal scrolling. On top of this, it's criminally easy to use, and its newer implementation <code class="content__code">display: flex;</code> is actually <a class="content__link" href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing#use_flexbox_over_older_layout_models">quite fast</a>.</p>

				<h3 class="content__title">The Viewport</h3>
				<p class="content__body">One of the important-to-mention tweaks to ensure a responsive experience, is setting the <code class="content__code">meta viewport</code> tag, which directs the browser to render your site in the way you would probably expect it to...</p>

<div class="pre__container">
<pre class="pre"><code class="pre__code">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
</code></pre>
</div>

				<p class="content__body">Without these directives, the browser will most likely try to render your web page at a desktop width of 800 to 1024 CSS pixels, making you pinch-to-zoom in order to read content. Setting the <code class="content__code">initial-scale=1</code> attribute also instructs the browser to set a 1:1 ratio of CSS pixels to device-independent pixels. Now, we'll have better control of how our content is viewed, and prevent the browser from doing any weird and unwanted scaling of our content.</p>

				<h3 class="content__title">Vendor-Prefixes</h3>
				<p class="content__body">Another critical part of responsive web design is an annoying but necessary evil - CSS vendor-prefixes. Vendor-prefixes are just one of the downsides to having a competitive environment between browsers. Although competition is good and encourages innovation, it means developers are left with the burden of makings sure their applications run in all environments. For the most part, all I've had to do to ensure this website is cross-browser compatible, is by incorporating <a class="content__link" href="https://github.com/postcss/autoprefixer">autoprefixer</a> via postcss in a gulp task. I simply run this task during my build process and main.css will be ready to be used in all major browsers - well, the <code class="content__code">"last 15 versions"</code> of major browsers as specified by <code class="content__code">"browserslist"</code> in my package.json. Also, to be fair, I don't just run the task and accept it as successful and complete, it's important that I do a lot of testing on different devices, emulators, and browsers to ensure autoprefixing is doing its job.</p>

				<h3 class="content__title">Tap targets</h3>
				<p class="content__body">Part of responsive web design entails building for an environment we don't typically develop <i>in</i>, and interactions we don't develop <i>with</i> - a big one being touch. Touch is a tricky interaction to deal with, mainly because touch isn't as predictable as cursor interactions, and well, some people have sausage fingers, some have long pretty nails, and some people tap like they're trying to break the screen. Your touch is not the same as my touch, so it's important to build in a buffer to make tap targets accessible, and for touch events to be successful. I've set each of the sidenav list items to have <code class="content__code">line-height: 36px;</code>, and made sure the inner anchor text has <code class="content__code">padding</code> that increases the target size for imprecise tappers. A similar <code class="content__code">line-height</code> was set for the text you're reading due to the links embedded into the content. This also helps with general legibility. Because we've had such uncertain experiences while tapping on our devices in the past, it's also important that, in addition to increasing tap targets, we give the user some type of feedback that yes, yes you did touch that thing successfully. Many mobile browsers conveniently <a class="content__link" href="https://developer.mozilla.org/en-US/docs/Web/CSS/:hover">apply the styles</a> of the pseudo classes <code class="content__code">:hover</code> and/or <code class="content__code">:focus</code> states after the target has been tapped, and because we've done that already, we're good to go - <i>awesome</i>.</p>

			<h2 id="resilience" class="content__heading">Resilience</h2>

				<p class="content__body">Device states (low power mode, device overheating, memory constraints, etc.) and networks (especially mobile networks) are unpredictable. <a class="content__link" href="http://www.urbandictionary.com/define.php?term=lie-fi&defid=4841142">LieFi</a> is a thing, and well, what happens if our server goes down? This unpredictability means that fast isn't always enough, and we can't rely on our users always making it to our origin server. Our applications must prioritize resiliency.</p>

				<h3 id="#offlineFirst" class="content__title">Offline First w/ Service Worker</h3>
				<p class="content__body">With such variability in device/network performance nowadays, it's increasingly difficult to rely on our applications/websites to be available to our users all the time, and well, we need to treat <a class="content__link" href="https://www.igvita.com/2015/01/26/resilient-networking/">offline as a norm, not an exception</a>. This is the part where <a class="content__link" href="https://developers.google.com/web/fundamentals/getting-started/primers/service-workers">service workers</a> come in to save the day. Service workers are scripts that our browser runs in the background apart from our web page, and act as a network proxy by handling requests. This site has leveraged service workers to provide one of their core benefits, offline functionality.<br>
				
				We first register our service worker when a user lands on any page of this site. Along with the registration, the service worker is directed to fetch and cache a specified array of resources - which I describe in more detail later in <a class="content__link" href="#CachingSW">Caching > Caching w/ Service Worker</a>. We can then use these locally cached files to respond to our users requests, avoiding the network entirely. So, if we have a user on the subway that lands on our homepage, then the train enters a tunnel where all network connection is lost, they will still be able to navigate between our pages. By the time they're done reading and navigate away from this site, the train may have exited the tunnel, and the user may never even know that they had lost network connectivity - this is pretty cool stuff. This type of degraded network experience, or complete loss of connectivity, happens to even the newest flagship phones on the latest and greatest LTE networks. We must not neglect this when creating web experiences.</p>

				<h3 class="content__title">Distributed assets w/ CloudFront</h3>
				<p class="content__body">Using Amazon's CloudFront CDN adds redundancy to our website, where if one of our components fail, be it our closest edge location or our origin server, the system as a whole continues to function. <a class="content__link" href="https://www.youtube.com/watch?v=M_V4R9Rn6cI#t=17m30s">Amazon's infrastructure is designed to fail</a>, so if an edge location fails for whatever reason, Amazon's infrastructure reroutes users to the nearest available edge location. Additionally, if our origin server burns to the ground in some spectacular fire, our edge locations continue to serve our cached files, even if they're stale. Although this redundancy isn't infallible, it's an added layer of resilience, and is a considerable improvement over a single origin server.</p>

			<h2 id="compression" class="content__heading">Compression</h2>

				<p class="content__body">I've used <a class="content__link" href="http://www.gzip.org/">gzip</a> to compress my text-based files, and have effectively reduced the file sizes of index.html, design.html, resume.html, main.css, and scripts.js by X%, X%, X%, and X% respectively (I'll try and update these figures as the content of these pages change).</p>

				<h3 class="content__title">Gzip</h3>
				<p class="content__body">The gzip utility can be employed on an Amazon S3 instance by first compressing the resource locally, uploading that compressed file to an S3 bucket, then explicitly setting the resource's <code class="content__code">Content-Encoding</code> header to <code class="content__code">gzip</code>. I currently implement gzip with gulp task <a class="content__link" href="https://www.npmjs.com/package/gulp-gzip">gulp-gzip</a>, because this is easy and seamlessly fits into my build process, although, this is not the only option when implementing gzip. For some time, I'd use the gzip command line utility, which is straightforward, but became relatively cumbersome. Another option is Amazon Cloudfront's configuration that will automatically compress files on-the-fly. With this configuration, there are <i>some</i> <a class="content__link" href="http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/ServingCompressedFiles.html">side effects</a> to be considered. CloudFront will only compress files that are between 1000 and 10,000,000 bytes, and will only do so if that file-size is pulled from the Content-Length header. These limitations are put into place by Amazon for good reason, but they relinquish the developer of the discretion when choosing where to implement gzip. Moreover, CloudFront also strips the Etag Header (see <a class="content__link" href="#caching">Caching</a>) when it compresses files on-the-fly. This means that when a file expires at the edge location, and another request is sent to the origin server, the origin always responds with the entire file, as opposed to a 304 (Not Modified) HTTP status code. By having to send the entire file again, this cuts into our performance latency budget. Lastly, CloudFront reserves the right to simply ignore compression instructions when servers are unusually busy. Consequently, I handle gzip in my Gulp build process, where I have more discretion and oversight.</p>

				<h3 class="content__title">Brotli</h3>
				<p class="content__body">For now, this site is sticking with gzip, but as of late, a new compression library has emerged as a more compelling alternative - one that offers consistently better compression rates than gzip, and has newfound support in <a class="content__link" href="http://caniuse.com/#feat=brotli">many browsers</a>; it's called Brotli. Facebook is using it, as well as Google, however, the same access to infrastructure is not afforded to me and this site :(. CloudFront distributions normalize the "Accept-Encoding" header to gzip, so the only way around this limitation is with <a class="content__link" href="http://calendar.perfplanet.com/2016/enabling-brotli-even-on-cdns-that-dont-support-it-yet/">a Service Worker script</a> to detect support.</p>

				<h3 class="content__title">Google's Closure Compiler</h3>
				<p class="content__body">I use <a class="content__link" href="https://developers.google.com/closure/compiler/">Google's Closure Compiler</a> to minify and compile scripts.js, and any embedded scripts, into "better Javascript". For the scripts on this site, the Closure Compiler removes whitespace, comments, and simplifies some of our JavaScript - I wouldn't go so far as to call it obfuscation, but it does make your once-legible JavaScript a little hard to follow - run the test code on their <a class="content__link" href="http://closure-compiler.appspot.com/home">web app</a> to see a quick example. The Closure Compiler also flags potentially dangerous operations and catches illegal JavaScript that survives into your build process. The savings after running scripts.js through the "simple" optimization setting, is XXX bytes (XX%), and XXX bytes (XX%) on our embedded scripts. Both scripts include a version of an already optimized modernizr script, so the savings seem somewhat limited.</p>

				<h3 class="content__title">HTTP/2 header compression</h3>
				<p class="content__body">HTTP/2 uses <a class="content__link" href="https://hpbn.co/http2/#header-compression">header compression</a> to reduce overhead, which can provide vast improvements in latency - being especially valuable for mobile users. With HTTP/1.x, headers are sent with every transfer of data, and quite frequently the headers don't even change, which means that there can be up to several kilobytes of unnecessary overhead on every transfer. However, with HTTP/2, both the client and the server keep an indexed list of previously shared headers, and fields only get updated when they change - a huge savings in overhead. HTTP/2 also employs <a class="content__link" href="http://www.stringology.org/DataCompression/sh/index_en.html">Static Huffman coding</a> to compress the size of the header fields themselves. The best part is, HTTP/2 is <a class="content__link" href="https://aws.amazon.com/about-aws/whats-new/2016/09/amazon-cloudfront-now-supports-http2/">enabled on CloudFront</a> by default - Woo! Easy performance win. However, Amazon hasn't yet provided the support for all HTTP/2 features. The main feature I would like to see support for is <a class="content__link" href="https://http2.github.io/faq/#how-can-i-use-http2-server-push">Server Push</a>, which is arguably the most compelling aspect of implementing HTTP/2. Server push enables the server to send multiple parallel responses to a single request from the client, which means we can send all the assets we'd like, even before the client discovers them, eliminating round-trips and massively improving latency costs. But hey, this section is suppose to be about compression, and we can't use server push with CloudFront anyways, so I'll table the topic for now.</p>


			<h2 id="design" class="content__heading">Design</h2>

				<h3 class="content__title">Accessibility</h3>
				<p class="content__body">Web accessibility is a critical part of providing equal opportunity and equal access to disabled people using the web. We can accomplish this by incorporating ARIA (Accessible Rich Internet Applications) attributes into our applications, and by following <a class="content__link" href="https://www.w3.org/WAI/gettingstarted/tips/developing">guidelines specified by the Web Accessibility Initiative</a>. We haven't had to declare many ARIA roles on this site, mainly because the site is so basic, but also because we cover many of these roles implicitly by using newer HTML5 elements like <code class="content__code">&lt;button&gt;</code>, <code class="content__code">&lt;nav&gt;</code>, and <code class="content__code">&lt;header&gt;</code>. To help us out a bit with this process, I downloaded the <a class="content__link" href="https://chrome.google.com/webstore/detail/accessibility-developer-t/fpkknkljclfencbdbgkenhalefipecmb">Accessibility Developer Tools</a> Chrome extension offered by Google Accessibility. This audit kept me in check by conducting a number of test, some of which include: making sure all of our images have <code class="content__code">alt</code> attributes, all of our links have descriptive text, and that our text-based elements have a reasonable contrast ratio.</p>

				<h3 class="content__title">Semantic HTML</h3>
				<p class="content__body">As I mentioned in <a class="content__link" href="#progressiveEnhancement">Progressive Enhancement</a>, we're implementing a content-first strategy, where our HTML is being enhanced by CSS and JavaScript, not dependant on them. It's very easy to write HTML with non-semantic elements, then render your poor markup invisible with CSS. With that in mind, incorporating semantic elements is pretty straightforward, especially with resources like the <a class="content__link" href="http://html5doctor.com/element-index/">HTML5 Element Index</a> to help us out.</p>

				<h3 class="content__title">Structured data</h3>
				<p class="content__body"><a class="content__link" href="https://schema.org/docs/gs.html">Schema.org Microdata</a> helps us add semantic information to our HTML, and assists us in explaining the content of our pages to search engines and other applications. I've implemented microdata mostly on resume.html, as it goes more in depth about me (a Person object) and my attributes (email, affiliations, nationality, etc). Google's <a class="content__link" href="https://search.google.com/structured-data/testing-tool">Structured Data Testing Tool</a> helps us catch any errors, and validate that our markup is on par with current standards.</p>

				<h3 class="content__title">Security w/ HTTPS</h3>
				<p class="content__body">Unencrypted communication over HTTP exposes us and our users with a number of security vulnerabilities, and honestly, with HTTPS being so easy to implement today, there is no reason to avoid it. We can effortlessly <a class="content__link" href="https://aws.amazon.com/certificate-manager/faqs/">enable HTTPS with CloudFront</a> and AWS Certificate Manager within a matter of minutes, and on top of that, it's free. There are also services like <a class="content__link" href="https://letsencrypt.org/">Let's Encrypt</a> that offer free SSL/TLS certificates - if you aren't set up with AWS. In addition to maintaining our website's integrity, and protecting our users privacy/security, SSL also enables the use of newer web platform features (like service worker, and HTTP/2) and APIs (like geolocation) for devs, and the cherry on top... it may even <a class="content__link" href="https://webmasters.googleblog.com/2014/08/https-as-ranking-signal.html">boost your pagerank in search engines</a>.</p>

				<h3 class="content__title">Image considerations</h3>
				<p class="content__body">Honestly, the floral image on this site is not my favorite, nor do I think it totally embodies my inner artistic vision, or whatever, but it does satisfy a list of requirements that makes it a great fit for this site. Given the context and how we utilize the image, the floral pattern gives us just about everything we are looking for, as an image that:</p>

				<ol class="content__list">
					<li>is colorful</li>
					<li>is seamless so we can tile it</li>
					<li>can be used as knockout text, and is still legible on a white background</li>
					<li>has a complicated enough visual composition so it doesn't <i>look</i> tiled</li>
					<li>wasn't made for a 2006 Myspace page</li>
				</ol>


			<h2 id="caching" class="content__heading">Caching</h2>

				<p class="content__body">Proper caching practices are key (Caching directives, CDNs, Service Workers), not only because good caching improves UX by reducing latency, but also because it reduces load on our servers and costs to transfer our data. Poor caching can also lead to versioning incongruity with between our files - not good.</p>

				<h3 class="content__title">Caching our HTML, CSS, and JavaScript</h3>
				<p class="content__body">I've specified a <code class="content__code">Cache-Control: no-cache</code> directive on our HTML, CSS, and JavaScript within the Amazon S3 console. Now, this doesn't mean we aren't caching our files (that would be <code class="content__code">no-store</code>), we are simply telling the browser to check with us before they use anything they have stored in the cache. I'm using this method of caching because the HTML, CSS, and JavaScript on this site change frequently, and I'd certainly like any changes I make to take effect as soon as possible. The way our client "checks with us" before using a cached resource is with the use of a validation token. By default, Amazon S3 has assigned each resource a validation token (<a class="content__link" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag">ETag</a>). The ETag for a resource is generated by our server, sent to our client, stored on the client's machine, and then sent back to us along with the client's next request to the server. If the server's ETag matches the one in the client's <code class="content__code">If-None-Match</code> HTTP header, then the server responds with a "304 Not Modified" response, which effectively eliminates the unnecessary re-transfer of unchanged resources (but still costs us a round trip).</p>

				<h3 class="content__title">Caching our Images</h3>
				<p class="content__body">With regards to our images, we take a very different approach to caching because, unlike our other files, our images don't change - they are immutable. It's for this reason that we can set a <code class="content__code">Cache-Control: max-age=31536000</code> directive on image assets, so our users will have permission to use the images in their cache for a full year before they have to ask for permission again. This is great for performance because our users don't have to endure a round trip to the server to "check with us", however, it does introduce a problem if we want to change our image(s). The user's browser will keep using the cached image, even if we update it on the server, that is, unless we implement versioning in our image urls - which we do. By appending a version #, or hash, or any unique identifying string to an image url, we can simply update that part of the url, and the browser will then recognize it as a new asset, and treat it as so. </p>

				<h3 class="content__title">CloudFront caching</h3>
				<p class="content__body">Because this site runs on an S3 origin server and is integrated with Amazon's CloudFront CDN, additional caching at edge locations provides lower latency and is a better performance optimization over a single origin server. This added layer of caching makes our site more resilient, available, and performant, but does introduce issues when we specify <code class="content__code">Cache-Control: no-cache</code> on our assets. If CloudFront respects our headers, we will have to ask our origin server permission to use cached files on <i>every</i> request. So, what's the point of a CDN if it has to hit our origin server for every request? Thankfully it doesn't. We can set a <a class="content__link" href="http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesMinTTL">Minimum TTL</a> that <a class="content__link" href="http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html#ExpirationDownloadDist">overrides</a> the value we've set in our <code class="content__code">Cache-Control</code> header by setting the asset's time to live (TTL) to 86,400 seconds - otherwise known as one day.</p>

				<h3 class="content__title">Cache-busting</h3>
				<p class="content__body">If we make a change to a file on our origin server, we must now wait for that file to expire in the caches of our edge locations before the latest content can be delivered to our users. This can take up to a day (our TTL). We can mitigate this issue by versioning our HTML, CSS, and JavaScript files, but at the same time, doing that would introduce more complexity into this site (think of all the paths we'd have to change). A better solution is to simply cache-bust with <a class="content__link" href="http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html">CloudFront Invalidations</a>. The downside being, these invalidations taking approximately 15 to 30 minutes to reach all Amazon edge locations. Also, there is a cap on the quantity of free invalidations that can be made per month per AWS account, but thankfully it's capped at a copious 1000 paths (at the time of this writing). Although caching with a CDN can introduce issues, they can be easily managed, and caching as a whole provides serious performance wins.</p>

				<h3 id="CachingSW" class="content__title">Caching w/ Service Worker</h3>
				<p class="content__body">Service Workers are crazy cool, and I introduced them in <a class="content__link" href="#offlineFirst">Resilience > Offline first</a> above, but because we're in the "Caching" section, I'm going to briefly touch on the caching aspect of this site's Service Worker. When <code class="content__code">service-worker.js</code> first installs, I've specified that a <a class="content__link" href="https://developer.mozilla.org/en-US/docs/Web/API/Cache">cache</a> be opened with <code class="content__code">caches.open()</code>, and then populated with the files we'd like to cache, with <code class="content__code">cache.addAll()</code>. In our case, we initially cache all 3 HTML files, and our main.css. In addition to our initial population of the cache, as users navigate to different pages on this site, the resources that are requested successfully are <a class="content__link" href="https://fetch.spec.whatwg.org/#dom-response-clone">cloned</a> and then added to the cache. Items that are placed into this cache do not expire unless they are deleted, so we're responsible for some housecleaning, or else risk reaching our storage allowance by the browser and having everything trashed. To keep a clean shop, it's good practice to version your <code class="content__code">CACHE_NAME</code>, and explicitly delete outdated caches with <code class="content__code">caches.delete()</code>.</p>

			<h2 id="cssOptimizations" class="content__heading">CSS optimization</h2>

				<p class="content__body">On this site, the CSS has been written in such a way that is maintainable and performant. It's also delivered in a form that's suitable for quick interpretation and construction by the browser.</p>

				<h3 class="content__title">Simple CSS selectors</h3>
				<p class="content__body">First, as trivial as it may sound, a lot of care went into the CSS class names (CSS selectors) on this site. Class names should be descriptive, but not limit their applications. I'm sure most web developers, at some point, have written two completely separate CSS classes in the same stylesheet, and have the <i>exact</i> same declarations - not very DRY. It's an easy trap to fall into if sufficient consideration isn't given to class naming and stylesheet structure. Nowadays, "smart" CSS preprocessors will collapse similar classes into each other to save bytes, but doing this still leaves the development versions of stylesheets bloated and mismanaged. Incorporating a CSS-naming-convention like <a class="content__link" href="https://en.bem.info/methodology/">BEM</a> or <a class="content__link" href="https://smacss.com/">SMACSS</a>, can help navigate around these issues - at least the organizational aspect. At the same time, we also need to consider our class naming conventions when optimizing for CSSOM construction. The less logic we use to describe our CSS rules, the easier and more straightforward it will be (and the faster it will take) for the browser to interpret those rules, calculate styles, and apply them to the DOM - this is why I've use a BEM-like syntax for class naming.</p>

				<h3 class="content__title">Embedding critical CSS</h3>
				<p class="content__body">Because CSS is a render-blocking resource, it's beneficial for this website to embed critical CSS, especially on index.html. Ideally, we <i>would</i> make use of server push, but again, even though we are using H2, CloudFront hasn't supported server push yet. Anyways, because we are embedding our CSS, it should be done in the head of a HTML document, and not on individual HTML elements. This is because inlining on elements can quickly lead to duplication of CSS rules, and on top of this, if a site has made use of <a class="content__link" href="https://www.w3.org/TR/CSP/">Content Security Policy</a>, CSS inlined on HTML elements will be blocked by default. Anyways, to verify that embedding critical CSS is a good performance optimization for this site, I tested the page load of index.html over the network with styles.css.gz, and with embedded CSS and the remaining styles (for the other pages on this site) prefetched. The results showed that.......................</p>

				<h3 class="content__title">Minification</h3>
				<p class="content__body">Throughout this site, Gulp has been put to work in many cases, and in this case, I'm using it to minify my CSS with <a class="content__link" href="https://www.npmjs.com/package/gulp-clean-css">glup-clean-css</a>. Clean-CSS minification strips out unnecessary whitespace, along with <a class="content__link" href="https://github.com/jakubpawlowicz/clean-css">a number of other optimizations</a>. However, I've still been looking for a gulp task that will safely compress (or obfuscate) my CSS class names across CSS, HTML, and JavaScript resources, without introducing buggy behavior.</p>

				<h3 class="content__title">SASS</h3>
				<p class="content__body"><a class="content__link" href="http://sass-lang.com/">SASS</a>, or "Syntactically Awesome Style Sheets", is a CSS preprocessor that transpiles feature-rich <code class="content__code">.scss</code> markup into <code class="content__code">.css</code> files. SASS is commonly used to add variables, mixins, nesting, and inheritance to CSS. I wanted to mention that SASS has been a godsend in some of my larger projects, however, its utility on this site has been pretty limited thus far. SASS provides the most value when stylesheets scale, however, because I've kept this site's CSS under tight control, I've mainly just used SASS to enable future scalability - something that is very important. Specifically, I've defined a few variables (like font, colors, and image paths), and put them in their own _variable.scss partial. I've also compartmentalized my CSS rules (BEM-style) by nesting element and modifier classes with the <code class="content__code">&amp;</code> directive. Take a look at <a class="content__link" href="">styles.scss on Github</a> if you would like to see what methods I've used to keep my CSS clean and scaleable.</p>

			<h2 id="imageOptimizations" class="content__heading">Image optimization</h2>

				<p class="content__body">The image that I've included on this site, in its original form (from a stock photo site), was a 6500 x 5000 JPEG weighing in at 8.9MB (floral.jpeg). Although this is a super high-res image, and great for flexibility when designing, it's also a horrendously inappropriate file to serve in production. This is not only because of the image's large file size, but also because this high of a resolution is simply not necessary for its purposes on this site; ergo, some serious optimization is in order.<br>

				<i>Quick disclaimer:</i> This is, by far, the most lengthy section of this site's documentation, but because images typically account for the most bytes on a web page and also occupy so much visual space on websites, it makes image optimization a compelling task.</p>

				<h3 class="content__title">The right image format</h3>
				<p class="content__body">To make floral.jpeg a better fit for the web, and at the same time, accomplish its design purpose, it was converted to a PNG-8 in Photoshop (now floral.<i>png</i>). This reformatting not only reduces the file size, but preserves the desired detail within the image - as PNG makes use of lossless compression algorithms. The size of floral.png was then further reduced by limiting the color palette to 128 colors, from 256 colors. This extra adjustment to the palette renders little perceivable difference in floral.png, but yields an additional 29.1% reduction in file size. By doing this, floral.jpeg has quickly gone from 8.9MB to 4.0MB - a quick 55% savings.<br>

				<i>Note:</i> Different images require different considerations when determining which format works best. For our floral image, PNG works really well. When optimizing images, I'll typically preview each format, reduce them to where they still pass the ol' eyeball test, and then see which format delivers the best file size.</p>

				<h3 class="content__title">Eliminating unnecessary pixels</h3>
				<p class="content__body">Intuitively, the most direct image optimization is to just make the image dimensions smaller - less image, less data. So, floral.png was sized down to a reasonable resolution, from 6500 x 5000 to 1400 x 1077. Because floral.png is seamless, it could've afforded a much larger reduction in resolution, but the decision to keep it at 1400 x 1077 was based on the design objectives of the site, the contents of the image, and the image's engagement with accompanying text on the site. floral.png has now gone from a 8.9MB file to 377KB - a total 95.8% savings.</p>

				<h3 class="content__title">Same image, multiple use cases</h3>
				<p class="content__body">floral.png is being used in more than one place on this site, and in these different spots, there are different functional uses of floral.png. The two situationally different uses are:</p>

				<ol class="content__list">
					<li>The header <code class="content__code">background-image</code> on resume.html/design.html</li>
					<li>The <code class="content__code">background-image</code> for the "Lyndon Core" text on index.html (a.k.a. knockout text)</li>
				</ol>

				<p class="content__body">These two applications demand different requirements from floral.png, and both only utilize bits-and-pieces of the full-resolution image; therefore, we have an opportunity to further optimize each case for their unique purpose.</p>

				<h3 class="content__title">Optimizing header background</h3>
				<p class="content__body">In our first case, we have floral.png being used as the <code class="content__code">background-image</code> in the header of resume.html and design.html. On these pages, we need the detail of the image preserved, but don't need the image in its entirety. Only the middle section of floral.png is visible in the header (because of <code class="content__code">background-position-y: center;</code>), so it seems obvious that there are expensive pixels of our image being transferred over the network, but never being seen because they've been placed out-of-view via CSS. Because of this, the top and bottom of floral.png were trimmed off to produce an new smaller image - floral-crop.png. This new image is the exact height of our header, and still 1400px wide. Using floral-crop.png over our full-sized floral.png maintains the seamlessness along the y-axis (necessary on larger screen sizes), while also saving XX% on file size.<br>

				<i>Note:</i> We will have to monitor the length of our page titles (e.g. "Site Design" on this page) to make sure that the text doesn't wrap on smaller screen sizes. In the case that it does, because floral.png was cropped, the <code class="content__code">background-image</code> is no longer seamless along the x-axis, so the result will look pretty ugly. If we must use a longer page title in the future, a media query will have to handle resizing the text to avoid it wrapping onto a new line.</p>

				<h3 class="content__title">Optimizing knockout text</h3>
				<p class="content__body">In our second case, floral.png <i>was</i> being used to create a knockout effect on our "Lyndon Core" text, where the full-sized image operated as our <code class="content__code">background-image</code>. Originally, floral.png was being resized down to fit the desired pattern behind the text, but it wasn't an optimal use of the image (hence the past tense). There were a lot of pixels that were loaded and never seen due to the loss of detail in the resizing. Here, it makes sense to create a smaller instance of floral.png as floral-sm.png, and simply let it display at its natural size. This way, we can spend our server's time & resources serving only pixels that will be used, and nothing more. Using a separate and smaller version of floral.png saves us 94.6% of the file size over using the full-sized PNG, and XX% of the original.</p>

				<h3 class="content__title">Leveraging delta encoding</h3>
				<p class="content__body">This is great and all, and it feels like we've done our job, but there are <i>still</i> large areas of floral-sm.png that we never see through our knockout letters. Unfortunately for us, raster images on the web are rectangular in nature, and not "Lyndon Core" shaped, or any other shape for that matter, so we can't directly avoid sending the unseen content of floral-sm.png - dang it. But, as it turns out, we can still save ourselves from incurring a lot of that data cost thanks to <a class="content__link" href="https://medium.com/@duhroach/how-png-works-f1174e3cc7b7">PNG's "filtering"</a> process that draws on <a class="content__link" href="https://en.wikipedia.org/wiki/Delta_encoding">delta encoding</a>. If we open up floral-sm.png in Photoshop, and white-out all the parts of floral-sm.png that aren't seen behind the knocked out letters of "Lyndon Core", we can seriously reduce the size of the image payload. Accordingly, <a class="content__link" href="">floral-xsm.png</a> is born. Now, we'll still be sending all the parts of the image that won't be used, however, those parts will now be much less data heavy. This new PNG, <a class="content__link" href="">floral-xsm.png</a> (XXXX bytes), is about a third of the size of <a class="content__link" href="">floral-sm.png</a> (XXXX bytes), and in total XX% smaller than our original floral.png.</p>

				<h3 class="content__title">The gotcha with floral-xsm.png</h3>
				<p class="content__body">Well, it kind of seems too good to be true, right? The byte-savings associated with floral-xsm.png are considerable, however it created somewhat of a nightmare with how our "Lyndon Core" text was being displayed. In Firefox, there were whites of the <code class="content__code">background-image</code> being exposed, and I had no idea why. After a bunch of researching, it turns out that browsers aren't too consistent with how text is rendered, more specifically the content area of the text itself. <a class="content__link" href="http://stackoverflow.com/questions/14573445/why-does-firefox-treat-helvetica-differently-from-chrome">This stackoverflow entry</a> highlights this issue. Because we risk accidentally rendering a whited-out part of our image behind our text, we have to be super careful, so floral-xsm.png is quite generous with how much of the original image remains. floral-xsm.png is still a huge optimization over floral-sm.png, but one that can make us feel a little uneasy, and reminds us of how precise we must be when implementing these kinds of image optimizations. Also, it's a good precautionary measure that we specify <code class="content__code">font-size</code>, <code class="content__code">background-size</code>, and <code class="content__code">line-height</code> in the same units (px) to ensure that if they are scaled up/down in any environment, they are scaled together one-for-one.</p>
 
				<h3 class="content__title">Optimizing image delivery</h3>
				<p class="content__body">So we've optimized the images themselves, but what about their performance over the network? While loading index.html, I noticed pretty quickly that floral-xsm.png was taking lower priority and had a later "start-time" than other resources in the in the <a class="content__link" href="https://developers.google.com/web/tools/chrome-devtools/network-performance/resource-loading">Chrome Devtools Network Tab</a>. This was probably because the browser's <a class="content__link" href="http://andydavies.me/blog/2013/10/22/how-the-browser-pre-loader-makes-pages-load-faster/">look-ahead pre-loader</a> wasn't recognizing the url for floral-sm.png within the CSS in a timely manner. This is an incredibly important issue; Not only do we need floral-sm.png to load like lightning, because it's the only way our user will see "Lyndon Core", but it's also the centerpiece of our users first impression on this site. It's, like, the only thing we've got going for us on that page. So, to solve this, I've considered two solutions:</p>
				<ol class="content__list">
					<li><code class="content__code">&#60;link rel="preload"&#62;</code> in the <code class="content__code">&#60;head&#62;</code> to preload floral-xsm.png, or</li>
					<li>Embed our floral-xsm.png as a base-64 encoded URI within our HTML</li>
				</ol>

				<h3 class="content__title">Data URI with TCP Slow Start</h3>
				<p class="content__body">The best part about the URI approach is that it ensures all the content in our <a class="content__link" href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/">critical rendering path</a> is loaded within the first round trip (minus our <a class="content__link" href="https://support.microsoft.com/en-us/help/172983/explanation-of-the-three-way-handshake-via-tcp-ip">three-way handshake</a>), and fits within 14KB or 10 TCP segments, which is a huge performance win. "Why is that?", you may ask. It's because this 14KB threshold is the initial size of the congestion window (cwnd) on a new TCP connection, and is part of the process known as <a class="content__link" href="https://hpbn.co/building-blocks-of-tcp/#slow-start">TCP Slow Start</a>. Slow Start is TCP's way of avoiding network congestion, by only using a fraction of the network's bandwidth, and doubling the data transfer allowance on each ACK from the client - this is known as the exponential growth algorithm. The growth of the congestion window continues until all the data has transferred, or to the point where packet loss occurs. When packet loss occurs, the <a class="content__link" href="https://hpbn.co/building-blocks-of-tcp/#congestion-avoidance">congestion avoidance algorithm</a> kicks in to better fit the current capabilities of the network. Back to my point - 14KB is important because it's approximately the amount of data we can send from our server without receiving an acknowledgement (ACK) from our client. Because our base-64 URI enables us to eliminate the network request, we can pack everything we need right into our HTML, and because it's only XXKB, it means we can render our page and give our users something to look at within one RT - a good UX.</p>

				<h3 class="content__title">Data URI drawbacks</h3>
				<p class="content__body">But this reduction in latency isn't without some gotchas: First, utilizing a URI increases the size of our image data because the <a class="content__link" href="http://stackoverflow.com/questions/11402329/base64-encoded-image-size">base64 output to input ratio is 4:3</a>, not including padding and other data. But, at the same time, when the HTML file is gzipped, it negates a lot of this bloat. Another tradeoff of embedding URIs is that the HTML typically isn't cached, so it's sent over the wire on every HTML request, but again, because we are caching our HTML (see <a class="content__link" href="#caching">Caching</a>), and floral-xsm.png is only used on index.html, it only makes it so that <i>changes</i> to the URI or HTML require the invalidation and retransmission of both - which isn't too costly in our case. The real gotcha here, is that on every request of index.html, cached or not, we must deal with the overhead of memory allocation to decode the URI into the PNG, <a class="content__link" href="http://dev.mobify.com/blog/data-uris-are-slow-on-mobile/">which can be slow</a>.</p>

				<h3 id="preloading" class="content__title">Preloading approach</h3>
				<p class="content__body">Our second option to speed up the rendering of floral-xsm.png, is a little more straightforward, and called link preloading. Just like <a class="content__link" href="#prefetching">prefetching</a>, preloading is a resource hint that we can leverage to let the browser know that we plan to use that specified asset on the current page, and prioritize its retrieval over other requests. We can easily declare an asset we'd like to preload with <code class="content__code">&#60;link rel="preload"&#62;</code>; however, current <a class="content__link" href="http://caniuse.com/#feat=link-rel-preload">Browser support for preload</a> isn't optimal, sitting at just less than 50% (at the time of this writing). So, in about half of our cases, we will have to fetch floral-xsm.png normally - when the client's browser finds it in our CSS.</p>

				<h3 class="content__title">Testing: Preloading vs. Data URI</h3>
				<p class="content__body">To determine which method of delivery we should choose for floral-xsm.png, both methods need to be tested on our pages. The initial results of index.html load with URI are...... TEST.  A quick test run with the preloading approach hints at........ TEST........ <a class="content__link" href="http://caniuse.com/#search=data%20uri">Browser support for Data URIs</a>, with our use case in mind, is just about perfect, and certainly won't be my support bottleneck on this site; so it's safe to say that..........  CONCLUSION.</p>

				<h3 id="whatAboutServerPush" class="content__title">What about Server Push?</h3>
				<p class="content__body">Ultimately, both the URI approach and the preload approach will be left outdated after we're able to exercise <a class="content__link" href="https://hpbn.co/http2/#server-push">Server Push with HTTP/2</a>. Server Push is a way for servers to respond to a single client request, with multiple responses. This is effectively what we are doing by embedding our CSS, JS, and Data URI into index.html - basically telling our users, "here you go, I know you're gonna ask for this anyways". Embedding has it's clear downsides, because we can't cache these files individually and reuse them on other pages. But, it's the reality we live with given our current infrastructure with AWS CloudFront. The support isn't there just yet. Nevertheless, we will still keep our URI/preload approach in our back pocket for clients that don't support HTTP/2, and those clients that have Server Push disabled.</p>

				<h3 class="content__title">Back to floral-crop.png</h3>
				<p class="content__body">When a user of this site lands on index.html, and subsequently clicks on the link that brings them to this page, it would be nice if the image used at the top (floral-crop.png) had already been downloaded by the browser. This would save us a lot of time in rendering the page, and would've been the case when using a single cached image throughout the entire site - instead, we have decided to use separate image assets that aren't interchangeable. This occurrence seems like a performance loss, or at least a negative externality of using two modified versions of the same image. However, there is a way we can get the best of both worlds by prefetching floral-crop.png.</p>

				<h3 id="prefetching" class="content__title">Prefetching</h3>
				<p class="content__body"><a class="content__link" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Link_prefetching_FAQ">Link prefetching</a>, similar to preloading <a class="content__link" href="#preloading">(mentioned a minute ago)</a>, is a feature of modern browsers that uses idle time to fetch and download files that will <i>most likely</i> be needed on subsequent requests. The browser will then store them in the cache for later use. Because prefetching is initiated after page load, it doesn't impact the <a class="content__link" href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/">critical rendering path</a>, which keeps our perceived page loads fast. floral-crop.png is the perfect candidate to be prefetched, mainly because every other page on this site uses it, and it's being <i>assumed</i> that a significant number of visitors will make the navigation to a second page. We don't have the user data to back this up just yet, however, it's what we're rolling with until we do. Because floral-crop.png seems like a good fit to be prefetched, we can apply this mechanism on index.html with...</p> 

<div class="pre__container">
<pre class="pre"><code class="pre__code">&#60;link rel="prefetch" src="images/floral-crop.png"&#62;
</code></pre>
</div>

				<p class="content__body">But of course, there are tradeoffs. The obvious caveat is the extra upfront data transfer costs for both the client and the server. Also, the prefetch resource hint <a class="content__link" href="http://caniuse.com/#feat=link-rel-prefetch">isn't supported</a> in all browsers, so there will be unavoidable instances (notably on iOS and Safari) where clients must wait a little longer for floral-crop.png. While support isn't optimal at the moment, there has be a better (more supported) way we can implement this...</p>

				<h3 class="content__title">Prefetching w/ Server Push</h3>
				<p class="content__body">Okay, well, this is probably our best option, but again, as I mentioned in <a class="content__link" href="#whatAboutServerPush">What about Server Push?</a>, CloudFront doesn't support Server Push just yet. We <i>would</i> push floral-crop.png down to our client with the request of index.html, and give it a <a class="content__link" href="https://hpbn.co/http2/#stream-prioritization">low stream priority</a> so that it wouldn't be competing for browser resources with our critical assets. Until the support is there, we're going to have to do this another way.</p>

				<h3 class="content__title">Prefetching w/ JavaScript</h3>
				<p class="content__body">Another way we can handle prefetching floral-crop.png is by way of the JavaScript <code class="content__code">Image()</code> constructor. This constructor will create a new <a class="content__link" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement">HTMLImageElement</a>, and fetch the image we pass to it. If we call the prefetch function after the page has loaded, the image will be fetched and preprocessed without interfering with our critical rendering path.</p>

<div class="pre__container">
<pre class="pre"><code class="pre__code">function prefetch() {
    (new Image()).src = &#39;images/floral-crop.png&#39;;
}
window.onload = prefetch;
</code></pre>
</div>
				
				<p class="content__body">Handling our prefetch this way seems a little hackish, and not entirely semantic, but it also gives us the most control over the behaviour of the prefetch. At the same time, it's arguable that we, as developers, shouldn't have this type of unlimited discretion. It may be best for us to <a class="content__link" href="https://w3c.github.io/resource-hints/#prefetch">let the browser decide</a> how/when the prefetch occurs (if at all), mainly because it's not an integral function of this site, and the browser definitely has a better understanding of the client's resource constraints than we do. For now, we're going to stick with the conservative and less supported approach - the prefetch resource hint. Heck, I don't know if Safari/iOS has plans of supporting the prefetching anytime soon, but if they do, it'll be an automatic win for us.</p>

				<h3 class="content__title">Prefetching + Service Worker</h3>
				<p class="content__body">Our prefetching method and our Service Worker pair pretty well together - especially because browser support for each aligns nicely. As our resource hint issues a request for floral-crop.png, our service worker sees the request, clones the response, and then adds it to the user's cache. Although we can just explicitly set the Service Worker to cache the floral-crop.png, we'd rather not, due to the reasons stated in the following section, Art direction.<br>

				<i>Spoiler:</i> I introduce different versions of the image (different sizes for different screen densities). We don't want to cache the wrong one, nor do we want to cache all of the different versions. So, we don't directly specify which image to cache in the service worker. Instead, we intercept requests made by our JavaScript and cache those responses.</p>

				<h3 class="content__title">Gulp-imagemin & OptiPNG</h3>
				<p class="content__body">After all of our optimizations, the last attempt at making our images as compact as possible, is to run them through <a class="content__link" href="http://optipng.sourceforge.net/">OptiPNG</a> - a command line "PNG optimizer that compresses image files to a smaller size, without losing any information". At this point, because all of our images have already been optimized through "save for web" in Photoshop, the additional savings from running OptiPNG's compression on our images folder was limited to XX%, or a measly XXX bytes. However, it's still a good catch to have in a build process. To make this streamline with the rest of my build process, I incorporated Gulp task <a class="content__link" href="https://www.npmjs.com/package/gulp-imagemin">gulp-imagemin</a>, which actually leverages the OptiPNG compression methods, among others.</p>

			<h2 id="artDirection" class="content__heading">Art direction</h2>

				<p class="content__body">Regardless of the lean, latency-reducing image delivery methods we decide on, there's a good chance we'll incur at least one more round trip to our server anyways - Why? Because <a class="content__link" href="https://developers.google.com/web/fundamentals/design-and-ui/media/images#art_direction">art direction</a> is important. It's easy to send a tiny image to our users and call it performant, although doing that doesn't always provide a complete and optimal user experience. Go figure. For one, screen resolutions vary wildly between devices, so our once-normal images now look blurry on newer devices with "Retina displays" and whatnot. On top of that, we should be using newer image formats, like webp, where we can, and avoid sending huge desktop images to mobile devices. This all goes into our process of art direction.</p>

				<h3 id="usingWebp" class="content__title">Using Webp</h3>
				<p class="content__body">As it turns out, we can provide even smaller image files with Google's <a class="content__link" href="https://developers.google.com/speed/webp/">Webp image format</a>. It's a relatively new image format, developed by the smart people at over at Google, that provides superior lossy and lossless compression for images on the web. However, there is only native support in Chrome, Opera, and Android Browser, which is around <a class="content__link" href="http://caniuse.com/#feat=webp">73% of the web</a>. But we're going to need 100% of our users to be able to see our images. Hmmmm... If we could detect what browser the user was on, and serve them the best image format, that would be ideal. We can do this type of feature detection client-side with a custom <a class="content__link" href="https://modernizr.com/">Modernizr</a> javascript build. If the client's browser supports Webp, Modernizr will be able to detect it, and a "webp" class will be added to our <code class="content__code">&#60;html&#62;</code> element. We can set rules for the descendants of the "webp" class in our CSS, and conditionally set different background images (.webp or .png). But that's not enough...</p>

				<h3 class="content__title">High-pixel-density displays</h3>
				<p class="content__body">It's our job to consider <a class="content__link" href="https://material.io/devices/">all the devices</a> front-end devs have to accommodate nowadays, which includes their dppx (dots per pixel). Blurry images simply degrade the UX and are no bueno. It's unacceptable to show users with a 3dppx screen (i.e. the Samsung Galaxy S5) an image that was optimized for a 1dppx screen (i.e. my Macbook Air). At the same time, it's also unacceptable to use high-res images everywhere - that's not being a good web citizen. We're going to have to test for this, but even then, that's not enough...</p>

				<h3 class="content__title">Images for smaller screens</h3>
				<p class="content__body">Looking at a specific example, the Samsung Galaxy S5, although we have a high 1080 x 1920 px screen resolution, we're also dealing with a screen that has a <a class="content__link" href="https://en.wikipedia.org/wiki/Device-independent_pixel">device-independent pixel</a> size of only 360 x 640 dp. Despite the high-res screen, this means that we'll only display 360 pixels of floral-crop.png, when the image itself is 1400 pixels wide. In addition to that, floral-crop.png will also look blurry on the S5. Well... this kinda sucks. But no worries, we'll create a new version of floral-crop.png, at only 540 px wide, and call it floral-crop-540.png. We can send this to clients where the media query <code class="content__code">max-width: 540px</code> resolves to true. This will save us (and our users) a lot of pain. Why 540 pixels? Well, it seems to be a good spot to start serving a smaller image. It's around the point where mobile devices come into play, which also begins the point of ultra high DPI screens. Trying to find the <i>perfect</i> breakpoint for our image is like trying to hit an elusive moving target, and should probably be backed up with user data (that we don't have yet). With that said, let's package this all together...</p>

				<h3 class="content__title">Low Quality Image Placeholders</h3>
				<p class="content__body">I use our implementation of floral-xsm.png as a <a class="content__link" href="http://www.guypo.com/introducing-lqip-low-quality-image-placeholders/">low quality image placeholder</a> (or LQIP), so the user gets immediate feedback with full support and minimal network overhead. Then, we query the client's device resolution and webp support with <a class="content__link" href="https://github.com/lyndoncore/lyndon/blob/master/js/inline.js#L33">this function</a> on embedded.js (the JavaScript that gets placed in the <code class="content__code">&#60;head&#62;</code> of index.html), and send them the appropriate version of our floral-xsm image. With this function, we have these possible outcomes:</p>

				<ol class="content__list">
					<li>Client doesn't support Webp but has <i>at least</i> 3dppx - fetch floral-xsm-3x.png</li>
					<li>Client does support Webp and has <i>at least</i> 3dppx - fetch floral-xsm-3x.webp</li>
					<li>Client doesn't support Webp but has <i>at least</i> 2dppx - fetch floral-xsm-2x.png</li>
					<li>Client does support Webp and has <i>at least</i> 2dppx - fetch floral-xsm-2x.webp</li>
					<li>Client doesn't support Webp and has <i>less than</i> 2dppx - chill and do nothing</li>
					<li>Client does support Webp and has <i>less than</i> 2dppx - chill and do nothing</li>
				</ol>

				<p class="content__body">After the most fitting image is fetched, we then replace our LQIP (floral-xsm.png) with our updated version. An important part here is that we do the swapping of the images <i>after</i> the new version is loaded, to avoid a FOUC.</p>

				<h3 class="content__title">Conditional prefetching</h3>
				<p class="content__body">For floral-crop.png, we do some similar testing, but there is an extra step we have to think about - our prefetch. Our prefetch occurs on index.html, so to make sure we don't fetch an image we won't end up using, we have to do some testing upfront. We replace our simple resource hint (mentioned above) with a <a class="content__link" href="https://github.com/lyndoncore/lyndon/blob/master/js/inline.js#L8">script injected resource hint</a>. The key, in this case, is to only prefetch resources that <b>make floral-crop smaller</b>. One of the reasons for doing this is that the images get exponentially larger with a 1x increase in resolution. Our possible outcomes are:</p>

				<ol class="content__list">
					<li>Client doesn't support Webp but has a screen width of <i>greater than</i> 540px - prefetch floral-crop.png</li>
					<li>Client does support Webp and has a screen width of <i>greater than</i> 540px - prefetch floral-crop.webp</li>
					<li>Client doesn't support Webp but has a screen width of 540px <i>or less</i> - prefetch floral-crop-540.png</li>
					<li>Client does support Webp and has a screen width of 540px <i>or less</i> - prefetch floral-crop-540.webp</li>
				</ol>

				<h3 class="content__title">Using the correct prefetched image</h3>
				<p class="content__body">When we make the subsequent navigation to design.html/resume.html from index.html, we're going to have to make sure that the image that is used for our header <code class="content__code">background-image</code> is the same image that we prefetched - or else the prefetch was totally useless. We accomplish this with CSS media queries. We nest the <code class="content__code">.webp .header</code> and <code class="content__code">.no-webp .header</code> CSS selectors inside <code class="content__code">@media (min-width: 540px)</code> and <code class="content__code">@media (max-width: 540px)</code> media queries, along with the <code class="content__code">.no-js-header .header</code> fallback. With each one of these declarations, we specify the corresponding image, so it's picked from our cache and avoids the network. The image is then used as a fast-response LQIP, and javascript testing is done to fetch and replace the background with higher-resolution images (just like with floral-xsm).</p>

				<h3 class="content__title">Avoiding a wasteful image request</h3>
				<p class="content__body">These media queries, that we've just defined, state that our header's <code class="content__code">background-image</code> is to toggle between the 540px-wide version, and the normal 1400px-wide version when we cross the 540px breakpoint. But I couldn't help but notice that when I loaded this page on desktop, and resized the browser's width to below 540px, there was a flash of the <code class="content__code">background-color</code>, and then our smaller image would paint afterwards. Not only is this a little unpleasant, it was completely unnecessary. We don't need to go to the network and fetch a smaller cropped version of the same image when we've already loaded the large one, right? To fix this, I added separate classes to our CSS, with the modifier flag <code class="content__code">--noRS</code> (short for no resize) when our JavaScript detects that we've already downloaded the larger image. These <code class="content__code">--noRS</code> classes aren't modified by our media queries, so we avoid fetching our smaller image. If you're currently on a resizable browser, resize the width to less than 540px, reload the page, and then scale the width up beyond 540px. You'll notice that the larger and smaller image toggle. However, if you reload the page above the 540px breakpoint, and repeat the behavior, you'll notice that we never fetch the smaller image. Another day, another saved request.</p>

				<h3 class="content__title">Conditional loading with <code class="content__code">srcset</code></h3>
				<p class="content__body">avatar.png hasn't been talked about much (if you haven't seen it yet, it's in the footer), but it too is optimized for high DPI devices by way of the <code class="content__code">srcset</code> attribute. First off, we specify a <code class="content__code">src</code> for the image, as a fallback for <a class="content__link" href="http://caniuse.com/#feat=srcset">browsers that don't support srcset</a> - this is just our 1x PNG. Then, we specify the images we'd like to display, given different density conditions.</p>

<div class="pre__container">
<pre class="pre"><code class="pre__code">&lt;img class=&quot;footer__avatar&quot; src=&quot;images/avatar-1x.png&quot; srcset=&quot;images/avatar-2x.png 2x, images/avatar-3x.png 3x&quot;&gt;
</code></pre>
</div>

				<p class="content__body">The reason we do this with avatar.png, and not our floral images, is because of it's place on the page - way below the fold. The <code class="content__code">srcset</code> attribute is parsed <i>before</i> any requests are made, so it's okay that it takes an extra RT to fetch the image, we're not going to need it right away. The <code class="content__code">srcset</code> attribute also ensures that only the most fitting image is downloaded, so we don't waste any valuable bytes.</p>

				<h3 class="content__title">Conditional loading images for poor connections</h3>
				<p class="content__body">Because mobile networks can vary wildly in bandwidth and latency, partially due to some <a class="content__link" href="https://hpbn.co/assets/diagrams/773ecb15832075c0b56021aa3ad15233.svg">infrastructure overhead</a>, it's also important to consider the network connection and serve appropriate images based on network constraints. However, the <code class="content__code">navigator.connection</code> API is simply too unreliable and <a class="content__link" href="https://developer.mozilla.org/en-US/docs/Web/API/Network_Information_API#Browser_compatibility">unsupported</a> at the moment. Also, the <code class="content__code">srcset</code> attribute can act as a means for the browser to make a logical decision on which image to fetch based on network constraints, but to my knowledge, this isn't being implemented in any browsers yet.</p>

				<h3 class="content__title">Our images with JavaScript disabled</h3>
				<p class="content__body">I had noticed in main.css that the classes to style our header looked like <code class="content__code">.webp .header {...}</code> and <code class="content__code">.no-webp .header {...}</code>. I mean, it makes sense because all possible cases are supported, right? Either we support webp, or we don't. Nope. What about the case where our modernizr script never runs, like when JavaScript is disabled, and consequently never applies to the <code class="content__code">.webp</code> and <code class="content__code">.no-webp</code> classes to our <code class="content__code">&#60;html&#62;</code> element? Honestly, I didn't really think about this case until I disabled JavaScript during a test, and the header catastrophically broke - whoops. To fix this, I defined a base <code class="content__code">.header</code> class in our CSS, <i>which I really should've done from the beginning</i>, and then used <code class="content__code">.webp .header {...}</code> and <code class="content__code">.no-webp .header {...}</code> to only apply the fitting <code class="content__code">background-image</code>. But that still left our JavaScript-less users with no image and just a boring <code class="content__code">background-color</code> fallback. Just because they don't have JavaScript enabled, doesn't mean they shouldn't get our sweet floral image. So, I nested our <code class="content__code">&#60;header&#62;</code> inside of a <code class="content__code">&#60;noscript&#62;</code> div with a <code class="content__code">.no-js-header</code> class. That class in our CSS acts as a way for our header to default to our floral-crop.png image with <code class="content__code">.no-js-header .header {...}</code>.</p>
			

			<h2 id="inTheWorks" class="content__heading">In the works</h2>

				<p class="content__body">Over time, I will gradually add components to this site that test design principals and create challenging performance problems. There's so much I'd like to do with this site, and so many cool new toys I want to play around with, but they'll have to come one-at-a-time. For now, this is what's in the pipeline:</p>

				<h3 class="content__title">Contact form</h3>
				<p class="content__body">I've implemented contact forms before, specifically <a class="content__link" href="https://formspree.io/">formspree.io</a>, that are incredibly easy and free to integrate into a static webpage (not an endorsement); however, I'd consider it a low priority relative to everything else I'd like to do on this site. Nevertheless, there is one strong case to implement a contact form sooner than later - the <code class="content__code">emailto</code> link behavior is pretty unpredictable, and can be annoying. I had a buddy look at my site, and he tested the "email me" button on index.html, and it opened his default email client on his Macbook... you know, the one nobody uses. It was this exact pain that drove me to customize my mailto behavior in Chrome to open Gmail in a browser window. It escaped me that not everybody customizes this behavior within their browsers, and still deal with this. But on the other hand, if <a class="content__link" href="https://jakearchibald.com/">Jake Archibald</a> is using the mailto method (on the sidebar), then it should be good enough for me - for now, at least.</p>

				<h3 class="content__title">JavaScript optimizations</h3>
				<p class="content__body">I haven't talked about this topic much, but it's something I want to dive into when I have the time to document it. For me, at least, the hard part isn't implementing everything on here, it's writting about it. In the near future, I want to document how I've tried to keep my JavaScript optimized, free of considerable memory leaks, and how I've made use of throttling/debouncing.</p>

		</article>

	</main>

	<footer class="footer">
		<div class="footer__contain">
			<nav class="footer__contain--left">
				<a href="index.html" class="footer__link">HOME</a>
				<a href="design.html" class="footer__link">DESIGN</a>
				<a href="resume.html" class="footer__link">RESUME</a>
			</nav>
			<div class="footer__contain--right">
				<span class="footer__blurb">made with <span class="footer__pseudoCode">code</span> by</span>
				<span class="footer__blurb--sm">...made by</span>
				<img class="footer__avatar" src="images/avatar-1x.png" srcset="images/avatar-2x.png 2x, images/avatar-3x.png 3x" alt="A cartoon-ish avatar of my face">
			</div>
		</div>
	</footer>

</body>
</html>