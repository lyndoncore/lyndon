<!DOCTYPE html>
<html id="html">
<head>
<title>Lyndon Core</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="css/main.css">
<script async src="js/dev-scripts.js"></script>
<link rel="shortcut icon" type="image/png" href="images/favicon.png"/>
</head>
<body data-page-name="design">

	<noscript><div class="no-js-header"></noscript>
	<header id="header" class="header">
		<a href="index.html" class="header__home">LYNDON CORE</a>
		<div id="header__titleBg" class="header__titleBg">
			<div class="header__titleBg--faux">
				<h1 class="header__title">Site Design</h1>
			</div>
		</div>
	</header>
	<noscript></div></noscript>

	<main id="main" class="main">

		<nav class="nav">
			<ul class="nav__list" id="sidebar">
				<li><a id="navIntro" class="nav__item" href="#intro">Intro</a></li>
				<li><a id="navToolkit" class="nav__item" href="#toolkit">Toolkit</a></li>
				<li><a id="navResponsiveness" class="nav__item" href="#responsiveness">Responsiveness</a></li>
				<li><a id="navCompression" class="nav__item" href="#compression">Compression</a></li>
				<li><a id="navDesign" class="nav__item" href="#design">Design</a></li>
				<li><a id="navCaching" class="nav__item" href="#caching">Caching</a></li>
				<li><a id="navCssOptimizations" class="nav__item" href="#cssOptimizations">CSS optimizations</a></li>
				<li><a id="navImageOptimizations" class="nav__item" href="#imageOptimizations">Image optimizations</a></li>
				<li><a id="navInTheWorks" class="nav__item" href="#inTheWorks">In the works</a></li>
			</ul>
		</nav>

		<article class="content">

			<h3 id="intro" class="content__heading">Intro</h3>

				<p class="content__body">Brutally simple. From conception, this site was designed to embody that attribute visually, but not so much under the hood. This decevingly simple site is a performance pet project, and utilizes some neat technology, so it runs fast just about anywhere, on just about anything. This page's purpose is to document the design decisions that were made during the creation of this site, and the methodology behind them. I encourage you to verify and challenge these design methods before implementing them yourself in your own projects. It has been a learning process, so if you discover any information here that is definitively incorrect/outdated, any of the links have broken, any typos, or find a bug of sorts, please <a class="content__link" href="mailto:lyndoncore@gmail.com">reach out to me</a> so it can be corrected.</p>

				<h5 class="content__title">An observation</h5>
				<p class="content__body">I think it's interesting how web industry leaders approach their personal website design. You see many of these really smart people implementing superficially simple sites (to name a few: <a class="content__link" href="https://stevesouders.com/">Steve Souders</a>, <a class="content__link" href="http://chriscoyier.net/">Chris Coyier</a>, <a class="content__link" href="https://jakearchibald.com/">Jake Archibald</a>, and <a class="content__link" href="https://www.igvita.com/">Ilya Grigorik</a>). I mean, I'm sure these guys could build/design whatever they want - actually, <a class="content__link" href="http://imgur.com/a/2JEpq">not too sure about Jake</a>. It's my guess that they probably prioritize building things that <i>work</i>, and at the same time, I think they understand that introducing more components into our already <a class="content__link" href="https://en.wikipedia.org/wiki/Complex_systems">complex systems</a> makes things typically <i>not</i> work. Making things work, and making them sexy aren't mutually exclusive, however, it's considerably difficult to do both. I'm no industry leader, but I've noticed a strong correlation between the more I learn about the web and how simple I want to make my site.</p>

			<h3 id="toolkit" class="content__heading">Toolkit</h3>

				<ul class="content__list">
					<li>HTML5</li>
					<li>CSS</li>
					<li>JavaScript</li>
					<li>Sass</li>
					<li>Gulp</li>
					<li>Modernizr</li>
					<li>Service Worker</li>
					<li>Git/Github</li>
					<li>Sublime Text</li>
					<li>Chrome DevTools</li>
					<li>Amazon S3</li>
					<li>Amazon Route 53</li>
					<li>Amazon CloudFront</li>
					<li>AWS Certificate Manager</li>
					<li>Photoshop CS6</li>
				</ul>
				<h5 class="content__title">Honorable Mentions:</h5>
				<ul class="content__list">
					<li>WebPageSpeedTest</li>
					<li>PageSpeed Insights</li>
					<li>Google Analytics</li>
					<li>Google's Closure Compiler</li>
					<li>PNG to WEBP converter</li>
					<li><a class="content__link" href="http://websemantics.co.uk/online_tools/image_to_data_uri_convertor/">Image to URI converter</a></li>
					<li>CanIUse.com</li>
				</ul>

			<h3 id="responsiveness" class="content__heading">Responsiveness</h3>

				<p class="content__body">I've employed media queries, flexbox, vendor prefixes, and some other minor tweaks to ensure this site's accessibility to all users on any reasonably modern device.</p>

				<h5 class="content__title">Progressive enhancement</h5>
				<p class="content__body">It may have been somewhat clear from my little <a class="content__link" href="#intro">intro</a>, but <a class="content__link" href="http://alistapart.com/article/understandingprogressiveenhancement">progressive enhancement</a> was always a primary consideration throughout the designing process of this site. The idea is to implement a content-first strategy, where our markup can stand alone, and is <i>enhanced</i> by our CSS and Javascript, not dependant on it (try reloading this page without CSS and disabled JavaScript). A complete experience should always be the outcome for any of the readers here, independent of device capabilities. I'm not going to cover every instance of progressive enchancement on this site, however, if you think of the "why?" behind many of these topics, progressive enhancement will be your answer.</p>

				<h5 class="content__title">Mobile-first</h5>
				<p class="content__body">A content-first strategy goes hand-and-hand with a mobile-first strategy, where the most important content (our HTML) is boiled down in its most restricted enviorment. Thinking mobile-first more litterally meant wireframing ideas for this site with mobile sized/shaped viewports before anything else. Doing this ensured a complete experience on smaller screens, as well as forcing the proper use of positive and negative visual spacing as the viewport grows into larger screens. The results were breakpoints dictated by the flow of content, and not optimized for any particular device or user-agent. These breakpoints were employed with CSS media queries, which simply define the rules for our conditional CSS, and although simple, are very powerful components in the design of responsive websites.</p>

				<h5 class="content__title">Flexbox</h5>
				<p class="content__body">Using the <a class="content__link" href="https://www.w3.org/TR/css-flexbox-1/">CSS Flexible Box Layout Module</a>, or Flexbox, has also made designing a responsive web experience easy and intuitive. Its <a class="content__link" href="http://caniuse.com/#search=flexbox">browser support</a> is pretty good with the use of vendor-prefixing, and if you haven't heard of it, or just getting around to learning it, there are a million good resources to help you learn the basics. The fluid nature of Flexbox makes designing with <code class="content__code">meta viewport</code> an easy alternative to using fixed-width elements/containers, where potential issues can be introduced with horizontal scrolling - <i>yikes</i>. On top of this, it's criminally easy to use, and its newer implementation <code class="content__code">display: flex;</code> is actually <a class="content__link" href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing#use_flexbox_over_older_layout_models">quite fast</a>.</p>

				<h5 class="content__title">The Viewport</h5>
				<p class="content__body">One of the important-to-mention but also well-known tweaks to ensure a responsive experience, is setting the <code class="content__code">meta viewport</code> tag to include the values <code class="content__code">width=device-width</code> and <code class="content__code">initial-scale=1</code>. Specifying these is nessecary for having the browser render your site in the way your would probably expect it to. Without these directives, the browser will most likely try to render your web page at a desktop width of 800 to 1024 CSS pixels, making you pinch-to-zoom in order to read content. Setting the <code class="content__code">initial-scale=1</code> attribute also instructs the broswer to set a 1:1 ratio of CSS pixels to device-independent pixels. Now, we'll have better control of how our content is viewed, and prevent the browser from doing any weird and unwanted scaling of our content.</p>

				<h5 class="content__title">Vendor-Prefixes</h5>
				<p class="content__body">Another critical part of responsive web design is an annoying but nessecary evil - CSS vendor-prefixes. Vendor-prefixes are just one of the downsides to having a competitive enviornment between browsers. Although competition is good and encourages innovation, it means developers are left with the burden of makings sure their applications run in all enviorments. For the most part, all I've had to do to ensure this website is cross-broswer compatable, is by incorporating <a class="content__link" href="https://github.com/postcss/autoprefixer">autoprefixer</a> via postcss in a gulp task. I simply run this task during my build process and main.css will be ready to be used in all major browsers - well, the <code class="content__code">"last 15 versions"</code> of major browsers as specified by <code class="content__code">"browserslist"</code> in my package.json. Also, to be fair, I don't just run the task and accept it as successful and complete, I also do a lot of testing on different devices, emulators, and browsers to ensure autoprefixing is doing its job.</p>

				<h5 class="content__title">Tap targets</h5>
				<p class="content__body">Part of responsive web design entails building for an enviornment and interations we don't typically develop <i>with</i> - a big one being touch. Touch is a tricky interation to deal with, mainly because touch isn't as predictable as cursor interactions, and well, some people have sausage fingers, some have long pretty nails, and some people tap like they're trying to break the screen - <i>looking at you, Mum</i>. Your touch is not the same as my touch, so it's important to build in a buffer to make tap targets accessable, and for touch events to be successful. I've set each of the sidebar nav list items to have <code class="content__code">line-height: 36px;</code>, and made sure the inner anchor text has <code class="content__code">padding</code> that increases the target size for imprecise tappers. A similar <code class="content__code">line-height</code> was set for the text you're reading due to the links embedded into the content. This also helps with general legibility. However, the links in our content don't share the same padding as the links in our sidebar. This is because our content shares the same real-estate as much of the area that readers use to scroll, which increases the likelihood of accidental link-tapping while scrolling - something <i>I cant stand</i>. Because we've had such uncertain experiences while tapping on our devices in the past, it's also important that, in addition to increasing tap targets, we give the user some type of feedback that yes, yes you did touch that thing successfully. Many mobile browsers conveniently apply the styles of the pseudo classes <code class="content__code">:hover</code> and/or <code class="content__code">:focus</code> states after the target has been tapped - <a class="content__link" href="https://developer.mozilla.org/en-US/docs/Web/CSS/:hover">See this (mentioned near the bottom)</a>.</p>

			<h3 id="compression" class="content__heading">Compression</h3>

				<p class="content__body">I've used <a class="content__link" href="http://www.gzip.org/">gzip</a> to compress my text-based files, and have effectively reduced the file sizes of index.html, design.html, resume.html, main.css, and scripts.js by X%, X%, X%, and X% respectively.</p>

				<h5 class="content__title">Gzip</h5>
				<p class="content__body">The gzip utility can be employed on an Amazon S3 instance by first compressing the resource locally, uploading that compressed file to an S3 bucket, then explicitly setting the resource's <code class="content__code">Content-Encoding</code> header to <code class="content__code">gzip</code>. I currently implement gzip with gulp task <a class="content__link" href="https://www.npmjs.com/package/gulp-gzip">gulp-gzip</a>, because this is easy and seemlessly fits into my build process, although, this is not the only option when implementing gzip. For some time, I'd use the gzip command line utility, which is straighforward, but became relitively cumbersome. Another option is Amazon Cloudfront's configuration that will automaticlly compress files on-the-fly. With this configuration, there are <i>some</i> side effects to be considered. CloudFront will only compress files that are bewteen 1000 and 10,000,000 bytes, and will only do so if that file-size is pulled from the Content-Length header. These limitiations are put into place by Amazon for good reason, but they relinquish the developer of the discression when choosing where to implement gzip. Moreover, CloudFront also strips the Etag Header (see <a class="content__link" href="#caching">Caching</a>) when it compresses files on-the-fly. This means that when a file expires at the edge location, and another request is sent to the origin server, the origin always responds with the entire file, as opposed to a 304 (Not Modified) HTTP status code. By having to send the entire file again, this cuts into our performance latency budget. Lastly, CloudFront reserves the right to simply ignore compression instructions when servers are unusually busy. Consequently, I handle gzip in my Gulp build process, where I have more discresion and oversight.</p>

				<h5 class="content__title">Brotli</h5>
				<p class="content__body">For now, this site is sticking with gzip, but as of late, a new compression library has immerged as a more compelling alternative - one that offers consistantly better compression rates than gzip, and has newfound support in <a class="content__link" href="http://caniuse.com/#feat=brotli">many browsers</a>; it's called Brotli. Facebook is using it, as well as Google, however, the same access to infrastructure is not afforded to me and this site :(. CloudFront distributions normalize the "Accept-Encoding" header to gzip, so the only way around this limitation is with <a class="content__link" href="http://calendar.perfplanet.com/2016/enabling-brotli-even-on-cdns-that-dont-support-it-yet/">a Service Worker script</a> to detect support.</p>

				<h5 class="content__title">Google's Closure Compiler</h5>
				<p class="content__body">I used <a class="content__link" href="https://developers.google.com/closure/compiler/">Google's Closure Compiler</a> to minify and compile scripts.js, and the inline scripts on index.html, into "better Javascript". For the scripts on this site, the Closure Compiler removed white space, comments, and simplified some of our JavaScript - I wouldn't go so far as to call it obfuscation, but it does make your once-legible JavaScript a little hard to follow - run the test code on their <a class="content__link" href="http://closure-compiler.appspot.com/home">web app</a> to see a quick example. The Closure Compiler also flags potentially dangerous operations and catches illegal JavaScript that survives into your build process. The savings after running scripts.js through the "simple" optimization setting, is XXX bytes (XX%), and XXX bytes (XX%) on our inline scripts. Both scripts include a version of an already optimized modernizr script, so the savings seem somewhat limited.</p>

				<h5 class="content__title">HTTP/2</h5>
				<p class="content__body">HTTP/2 uses <a class="content__link" href="https://http2.github.io/faq/#why-do-we-need-header-compression">header compression</a> to reduce overhead and can provide vast improvements in latency - being especially valuable for mobile users. HTTP/2 also offers multiplexing and stream priority - which should be additional improvements to overall performance and UX. The best part is, HTTP/2 is <a class="content__link" href="https://aws.amazon.com/about-aws/whats-new/2016/09/amazon-cloudfront-now-supports-http2/">enabled on CloudFront</a> by defualt - Woo! Easy performance win. However, Amazon hasn't yet provided the support for all HTTP/2 features. The main feature I would like to see support for is <a class="content__link" href="https://http2.github.io/faq/#how-can-i-use-http2-server-push">Server Push</a>, which is arguably the most compelling aspect of implementing HTTP/2. Server push enables the server to send multiple parallel responses to a single request from the client, which means we can send all the assets we'd like, even before the client discovers them, eliminating round-trips and massively improving latency costs. But hey, this section is suppose to be about compression, and I cant use server push with CloudFront anyways, so I'll table the topic for now.</p>


			<h3 id="design" class="content__heading">Design</h3>

				<h5 class="content__title">Image considerations</h5>
				<p class="content__body">TALK ABOUT HOW floral image was chosen because it was a tiled pattern, and media queries are used to stop its growth at a certain point and repeat instead. Also how it was centered in order to have a predictable overlay of text on smaller screen sizes.


				What book did i read? Tiny Tweaks design as stated by <a class="content__link" href="http://www.lukew.com/ff/entry.asp?1514">Luke Wroblewski</a>. I can afford this design because I have the "luxury of brutally simple Web pages". Although there are more invariably models than the ones identified by Mr. Wroblewski, deviating far from normal design patterns typically results in an uncomfortable and unfamiliar UX.

				Also maybe talk about the email button and it's issues with emailto. 

				Image selection. To be perfectly honest, I'm not in love with floral.png, but it gets the job done, and I'm just so incredibly sick of searching for stock images, really. Requirements 1) something that can have text overlayed on top of it, and still be legible. this goes hand and hand with it also being able to be overlaid onto text with a solid background. so not too much sudden contrast in the image 2) Is seamless along the y axis for larger screen sizes. 3) it's content is complicated enough that it visually doesn't LOOK like tile. 4) color variation. 5) wasn't made for a preteen's myspace. 

				Mention font scaling with EMs and REM and Handling touch inputs on mobile, line height to touch links easier, buttons large enough for touch. -- maybe in a Stuff I dont Have To Worry About section?

				<a class="content__link" href="http://html5doctor.com/downloads/h5d-sectioning-flowchart.png">Semantic HTML</a> and <a class="content__link" href="https://schema.org/docs/gs.html">Schema.org Microdata</a>. This site was designed to still make sense, even if styles.css fails to deliver. 

				Enabling HTTPS with cloudfront and AWS Certificate Manager. Protecting your resources with HTTPS protects your users, protects the integrity of your assets, enables the use of newer web platform features and APIs for devs, may boost your pagerank in search engines, <i>and</i> is free - this one's a no-brainer. 

				resiliency

				Using CloudFront edge locations makes it so that there is no single point of failure to the site. if my origin server goes down, there are many distrubuted versions of the site cached all over the US (and canada or whatever). As soon as I get around to implementing a srvice worker, resilency will get it's own section entirely.

				</p>

			<h3 id="caching" class="content__heading">Caching</h3>

				<p class="content__body">Proper caching practices are key (Caching directives, CDNs, Service Workers), not only becuase good caching improves UX by reducing latency, but also because it reduces load on our servers and costs to transfer our data. Poor caching can also lead to versioning incongruity with between our files - not good.</p>

				<h5 class="content__title">Caching our HTML, CSS, and JavaScript</h5>
				<p class="content__body">I've specified a <code class="content__code">Cache-Control: no-cache</code> directive on our HTML, CSS, and JavaScript within the Amazon S3 console. Now, this doesn't mean we aren't caching our files (that would be <code class="content__code">no-store</code>), we are simply telling the browser to check with us before they use anything they have stored in the cache. I'm using this method of caching because the HTML, CSS, and JavaScript on this site change frequently, and I'd certainly like any changes I make to take effect as soon as possible. The way our client "checks with us" before using a cached resource is with the use of a validation token. By default, Amazon S3 has assigned each resource a validation token (<a class="content__link" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag">ETag</a>). The ETag for a resource is generated by our server, sent to our client, stored on the client's machine, and then sent back to us along with the client's next request to the server. If the server's ETag matches the one in the client's <code class="content__code">If-None-Match</code> HTTP header, then the server responds with a "304 Not Modified" response, which effectively eliminates the unnecessary re-transfer of unchanged resources (but still costs us a round trip).</p>

				<h5 class="content__title">Caching our Images</h5>
				<p class="content__body">With regards to our images, we take a very different approach to caching because, unlike our other files, our images don't change - they are immutable. It's for this reason that we can set a <code class="content__code">Cache-Control: max-age=31536000</code> directive on image assets, so our users will have permission to use the images in their cache for a full year before they have to ask for permission again. This is great for performance because our users don't have to endure a round trip to the server to "check with us", however, it does introduce a problem if we want to change our image(s). The user's browser will keep using the cached image, even if we update it on the server, that is, unless we implement versioning in our image urls - which is exactly what I've done. By appending a version #, or hash, or any unique identifying string to an image url, we can simply update that part of the url, and the browser will then recognize it as a new asset, and treat it as so. </p>

				<h5 class="content__title">CloudFront caching</h5>
				<p class="content__body">Because this site runs on an S3 origin server that is integrated with Amazon's CloudFront CDN, additional caching at edge locations provides lower latency and is a better performance optimization over a single origin server. This added layer of caching makes our site more resilient, available, and performant, but does introduce issues if we specify <code class="content__code">Cache-Control: no-cache</code> on our assets (which we do). If CloudFront respects our headers, we will have to ask our origin server permission to use cached files on <i>every</i> request. So, what's the point of a CDN if it has to hit our origin server for every request? Thankfully it doesn't, we can set a <a class="content__link" href="http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesMinTTL">Minimum TTL</a> that <a class="content__link" href="http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html#ExpirationDownloadDist">overrides</a> the value we've set in our <code class="content__code">Cache-Control</code> header by setting the asset's time to live (TTL) to 86,400 seconds - otherwise known as one day.<br>

				If we make a change to a file on our origin server, we must now wait for that file to expire in the caches of our edge locations before the latest content can be delivered to our users. This can take up to a day (our TTL). We can mitigate this issue by versioning our immutable files, but at the same time, doing that would introduce more complexity into this site. A better solution is to simply cach-bust with <a class="content__link" href="http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html">CloudFront Invalidations</a>. The downside being, these invalidations taking approximatly 15 to 30 minutes to reach all Amazon edge locations. Furthermore, there is a cap on the quantity of free invalidations that can be made per month per AWS account, but thankfully it's capped at a copious 1000 paths (at the time of this writing). Although caching with a CDN can introduce issues, they can be easily managed, and caching as a whole provides serious performance wins.</p>

				<h5 class="content__title">Caching with our Service Worker</h5>
				<p class="content__body">Service Workers are crazy cool, and I talk more about them in <a class="content__link" href="">Resiliency > Offline first</a> below, but because we're in the "Caching" section, I'm just going to breifly touch on the caching aspect of this site's Service Worker. When <code class="content__code">service-worker.js</code> first installs, I've specified that a <a class="content__link" href="https://developer.mozilla.org/en-US/docs/Web/API/Cache">cache</a> be opened with <code class="content__code">caches.open()</code>, and then populated with the files we'd like to cache <code class="content__code">cache.addAll()</code>, which in our case is just index.html, for now. As users navigate to different pages on this site, the resources that requested successfully are <a class="content__link" href="https://fetch.spec.whatwg.org/#dom-response-clone">cloned</a> and then added to the cache. Items that are placed into this cache do not expire unless they are deleted, so we're responsible for some housecleaning, or else risk reaching our storage allowance by the browser and having everything trashed. To keep a clean shop, it's good practice to version your <code class="content__code">CACHE_NAME</code>, and <code class="content__code">caches.delete()</code> older caches.</p>

			<h3 id="cssOptimizations" class="content__heading">CSS optimizations</h3>

				<p class="content__body">On this site, the CSS has been written in such a way that is maintainable and performant. It too, has been delivered in a form that's suitable for quick interpretation and construction by the browser.</p>

				<h5 class="content__title">Simple CSS selectors</h5>
				<p class="content__body">First, as trivial as it may sound, a lot of care went into the CSS class names (CSS selectors) on this site. Class names should be descriptive, but not limit their applications. I'm sure most web developers, at some point, have written two completely separate CSS classes in different parts of the stylesheet that have the <i>exact</i> same declarations - not very DRY. It's an easy trap to fall into if sufficient consideration isn't given to class naming and stylesheet structure. Nowadays, smart CSS preprocessors will collapse similar classes into eachother to save bytes, but doing this still leaves the development versions of stylesheets bloated and mismanaged. Incorporating a CSS-naming-convention like <a class="content__link" href="https://en.bem.info/methodology/">BEM</a> or <a class="content__link" href="https://smacss.com/">SMACSS</a>, can help navigate around these issues. At the same time, we also need to consider our class naming conventions when optimizing for CSSOM construction. The less logic we use to describe our CSS rules, the easier and more straightforawrd it will be (and the faster it will take) for the browser to interpret those rules, calculate styles, and apply them to the DOM.</p>

				<h5 class="content__title">Inlining critical CSS</h5>
				<p class="content__body">Because CSS is a render-blocking resource, it's benefitial for this website to inline critical CSS, especially on index.html. It's important to breifly note that CSS should be inlined in the head of a HTML document, and not on individual HTML elements. This is because inlining on elements can quickly lead to duplication of CSS rules, and on top of this, if a site has made use of <a class="content__link" href="https://www.w3.org/TR/CSP/">Content Security Policy</a>, CSS inlined on HTML elements will be blocked by default. Anways, to verify that inlining is a good performance optimization for this site, I tested the page load of index.html over the network with styles.css.gz, and with inlined critical CSS and the remaining styles (for the other pages on this site) prefetched. The results showed that.......................</p>

				<h5 class="content__title">Minification</h5>
				<p class="content__body">Throughout this site, Gulp has been put to work in many cases, and in this case, I'm using it to minify my CSS with <a class="content__link" href="https://www.npmjs.com/package/gulp-clean-css">glup-clean-css</a>. Clean-CSS minification strips out unnessecary whitespace, along with <a class="content__link" href="https://github.com/jakubpawlowicz/clean-css">a number of other optimizations</a>. However, I've still been looking for a gulp task that will safely compress my CSS class names across CSS, HTML, and JavaScript resources, without introducing buggy behavior.</p>

				<h5 class="content__title">SASS</h5>
				<p class="content__body">I wanted to mention that Syntastically Awesome Style Sheets (SASS) has been a godsend in some of my larger projects, however, its utility on this site hasn't really been valuable thus far. I've mainly just used SASS within this project to define a few variables, compartmentalize my css rules, and create a CSS infrastructure that will scale - that is, <i>if</i> the decision is made to add more modules to this site. At the time of this writing, SASS has been minimally incorporated, but is poised to contribute significantly if this site's stylesheet grows.</p>

			<h3 id="imageOptimizations" class="content__heading">Image optimizations</h3>

				<p class="content__body">The image that I've included on this site, in its original form (from a stock photo site), was a 6500 x 5000 JPEG weighing in at 8.9MB (floral.jpeg). Although this is a super high-res image, and great for flexibility when designing, it's also a horrendously innapporpriate file to serve in production. This is not only because of the image's large file size, but also because this high of a resolution is simply not nessecary for its purposes on this site; ergo, some serious optimization is in order.<br>

				<i>Quick disclaimer:</i> This is, by far, the most lengthy section of this site's documentation, but because images typically account for the most bytes on a web page and also occupy so much visual space on websites, it makes image optimization a compelling task.</p>

				<h5 class="content__title">The right image format</h5>
				<p class="content__body">To make floral.jpeg a better fit for the web, and at the same time, accomplish its design purpose, it was converted to a PNG-8 in Photoshop CS6 (now floral.<i>png</i>). This reformatting not only reduces the file size, but preserves the desired detail within the image - as PNG makes use of lossless compression algorithms. The size of floral.png was then further reduced by limiting the color palette to 128 colors, from 256 colors. This extra adjustment to the palette renders little perceivable difference in floral.png, but yields an additional 29.1% reduction in file size. By doing this, floral.jpeg has quickly gone from 8.9MB to 4.0MB - a quick 55% savings.<br>

				<i>Note:</i> Different images require different considerations when determining which format works best. For our floral image, PNG works really well. When optimizing images, I'll typically preview each format, reduce them to where they still pass the ol' eyeball test, and then see which format delivers the best file size.</p>

				<h5 class="content__title">Eliminating unnecessary pixels</h5>
				<p class="content__body">Intuitively, the most direct image optimization is to just make the image dimensions smaller - less image, less data. So, floral.png was sized down to a reasonable resolution, from 6500 x 5000 to 1400 x 1077. Because floral.png is seamless, it could've afforded a much larger reduction in resolution, but the decision to keep it at 1400 x 1077 was based on the design objectives of the site, the contents of the image, and the image's engagement with accompanying text on the site. floral.png has now gone from a 8.9MB file to 377KB - a total 95.8% savings.</p>

				<h5 class="content__title">Same image, multiple use cases</h5>
				<p class="content__body">floral.png is being used in more than one place on this site, and in these different spots, there are different functional uses of floral.png. The two situationally different uses are:</p>

				<ol class="content__list">
					<li>The header <code class="content__code">background-image</code> on resume.html/design.html</li>
					<li>The <code class="content__code">background-image</code> for the "Lyndon Core" text on index.html</li>
				</ol>

				<p class="content__body">These two applications demand different requirements from floral.png, and both only utilize bits-and-pieces of the full resolution image; therefore, we have an oppurtunity to further optimize each case for their unique purpose.</p>

				<h5 class="content__title">Optimizing header background</h5>
				<p class="content__body">In our first case, we have floral.png being used as the <code class="content__code">background-image</code> in the header of resume.html and design.html. On these pages, we need the detail of the image preserved, but don't need the image in its entirety. Only the middle section of floral.png is visable in the header (because of <code class="content__code">background-position-y: center;</code>), so it seems obvious that there are expensive pixels being transfered over the network, but never being seen because they've been placed out-of-view via CSS. Because of this, the top and bottom of floral.png were trimmed off to produce an new smaller image - floral-crop.png. Using floral-crop.png over our full-sized floral.png maintains the seamlessness along the y-axis (nessecary on larger screen sizes), while also saving XX% on file size.<br>

				<i>Note:</i> We will have to monitor the length of our page titles (e.g. "Site Design" on this page) to make sure that the text doesn't wrap on smaller screen sizes. In the case that it does, because floral.png was cropped, the <code class="content__code">background-image</code> is no longer seamless along the x-axis, so the result will look pretty ugly. If we must use a longer page title in the future, a media query will have to handle resizing the text to avoid it wrapping onto a new line.</p>

				<h5 class="content__title">Optimizing knockout text</h5>
				<p class="content__body">In our second case, floral.png <i>was</i> being used to create a knockout effect on our "Lyndon Core" text, where the full-sized image operated as our <code class="content__code">background-image</code>. Originally, floral.png was being resized down to fit the desired pattern behind the text, but it wasn't an optimal use of the image (hence the past tense). There were a lot of pixels that were loaded and never even seen due to the loss of detail in the resizing. Here, it makes sense to create a smaller instance of floral.png as floral-sm.png, and simply let it display at it's natural size. This way, we can spend our server's time & resources serving only pixels that will be used, and nothing more. Using a seperate and smaller version of floral.png saves us 94.6% of the file size over using the full-sized PNG, and XX% of the original.</p>

				<h5 class="content__title">Leveraging delta encoding</h5>
				<p class="content__body">This is great and all, and it feels like we've done our job, but there are <i>still</i> large areas of floral-sm.png that we never see behind our knockout letters. Unfortunately for us, raster images on the web are rectangular in nature, and not "Lyndon Core" shaped, or any other shape for that matter, so we can't directly avoid sending the unseen content of floral-sm.png - dang it. But, as it turns out, we can still save ourselves from incurring a lot of that data cost thanks to <a class="content__link" href="https://medium.com/@duhroach/how-png-works-f1174e3cc7b7">PNG's "filtering"</a> process that draws on <a class="content__link" href="https://en.wikipedia.org/wiki/Delta_encoding">delta encoding</a>. If we open up floral-sm.png in Photoshop, and white-out all the parts of floral-sm.png that aren't seen behind the knocked out letters of "Lyndon Core", we can seriously reduce the size of the image payload. And so, <a class="content__link" href="">floral-xsm.png</a> is born. Now, we'll still be sending all the parts of the image that won't be used, however, those parts will now be much less data heavy. This new PNG, <a class="content__link" href="">floral-xsm.png</a> (XXXX bytes), is about a third of the size of <a class="content__link" href="">floral-sm.png</a> (XXXX bytes), and in total XX% smaller than our original floral.png.</p>

				<h5 class="content__title">The gotcha with floral-xsm.png</h5>
				<p class="content__body">Well, it kind of seems too good to be true, right? The byte-savings associated with floral-xsm.png are considerable, however it created somewhat of a nightmare with how our "Lyndon Core" text was being displayed. In Firefox, there were whites of the <code class="content__code">background-image</code> being exposed, and I had no idea why. After a bunch of researching, it turns out that browsers aren't too consistent with how text is rendered, more specifically the content area of the text itself. <a class="content__link" href="http://stackoverflow.com/questions/14573445/why-does-firefox-treat-helvetica-differently-from-chrome">This stack overflow entry</a> highlights this issue. Because we risk accidentally rendering a whited-out part of our image behind our text, we have to be super careful, so floral-xsm.png is quite generous with how much of the original image remains. floral-xsm.png is still a huge optimization over floral-sm.png, but one that can make us feel a little uneasy, and reminds us of how precice we must be when implementing these kinds of image optimizations. Also, it's a good precautionary measure that we specify <code class="content__code">font-size</code>, <code class="content__code">background-size</code>, and <code class="content__code">line-height</code> in the same units (px) to ensure that if they are scaled up/down in any enviornment, they are scaled together one-for-one.</p>

				<h5 class="content__title">Optimizing image delivery</h5>
				<p class="content__body">So we've optimized the images themselves, but what about their performance over the network? While loading index.html, I noticed pretty quickly that floral-xsm.png was taking lower priority and had a later "start-time" than other resources in the in the <a class="content__link" href="https://developers.google.com/web/tools/chrome-devtools/network-performance/resource-loading">Chrome Devtools Network Tab</a>. This was probably because the browser's <a class="content__link" href="http://andydavies.me/blog/2013/10/22/how-the-browser-pre-loader-makes-pages-load-faster/">look-ahead pre-loader</a> wasn't recognizing the url for floral-sm.png within the CSS in a timely manner. This is an incredibly important issue; Not only do we need floral-sm.png to load like lightning, because it's the only way it will render "Lyndon Core", but it's also the centerpeice of our users first impression on this site. It's, like, the only thing we've got going for us on that page. So, to solve this, I've considered two solutions:</p>
				<ol class="content__list">
					<li><code class="content__code">&#60;link rel="preload"&#62;</code> in the <code class="content__code">&#60;head&#62;</code> to preload floral-xsm.png, or</li>
					<li>Inline our floral-xsm.png as a base-64 encoded URI within our HTML</li>
				</ol>

				<h5 class="content__title">Data URI with TCP Slow Start</h5>
				<p class="content__body">The best part about the URI approach is that it ensures all the content in our <a class="content__link" href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/">critical rendering path</a> is loaded within the first round trip (minus our <a class="content__link" href="https://support.microsoft.com/en-us/help/172983/explanation-of-the-three-way-handshake-via-tcp-ip">three-way handshake</a>), and fits within 14KB or 10 TCP segments, which is a huge performance win. "Why is that?", you may ask. It's because this 14KB threshold is the initial size of the congestion window (cwnd) on a new TCP connection, and is part of the process known as <a class="content__link" href="https://hpbn.co/building-blocks-of-tcp/#slow-start">TCP Slow Start</a>. Slow Start is TCP's way of avoiding network congestion, by only using a fraction of the network's bandwidth, and doubling the data transfer allowance on each ACK from the client - this is known as the exponential growth algorithm. The growth of the congestion window continues until all the data has transfered, or to the point where packet loss occurs. When packet loss occurs, the <a class="content__link" href="https://hpbn.co/building-blocks-of-tcp/#congestion-avoidance">congestion avoidance algorithm</a> kicks in to better fit the current capabilities of the network. Anyways, back to my point - 14KB is important because it's approximately the amount of data we can send from our server without receiving an aknowledgement (ACK) from our client. Because our base-64 URI enables us to eliminate the network request, we can pack everything we need right into our HTML, and because it's only XXKB, it means we can render our page and give our users something to look at within one RT - a good UX.</p>

				<h5 class="content__title">Data URI drawbacks</h5>
				<p class="content__body">But this reduction in latency isn't without some gotchas: First, utilizing a URI increases the size of our image data because the <a class="content__link" href="http://stackoverflow.com/questions/11402329/base64-encoded-image-size">base64 output to input ratio is 4:3</a>, not including padding and other data. But, at the same time, when the HTML file is gziped, it negates a lot of this bloat. Another tradeoff of inlining URIs is that the HTML typically isn't cached, so it's sent over the wire on every HTML request, but again, because we are caching our HTML (see <a class="content__link" href="#caching">Caching</a>), and floral-xsm.png is only used on index.html, it only makes it so that <i>changes</i> to the URI or HTML require the invalidation and retransmition of both - which isn't too costly in our case. The real gotcha here, is that on every request of index.html, cached or not, we must deal with the overhead of memory allocation to decode the URI into the PNG, <a class="content__link" href="http://dev.mobify.com/blog/data-uris-are-slow-on-mobile/">which can be slow</a>.</p>

				<h5 id="preloading" class="content__title">Preloading approach</h5>
				<p class="content__body">Our second option to speed up the rendering of floral-xsm.png, is a little more straightforward, and called link preloading. Just like <a class="content__link" href="#prefetching">prefetching</a>, preloading is a resource hint that we can leverage to let the browser know that we plan to use that specified asset on the current page, and prioritze its retreival over other requests. We can easily declare an asset we'd like to preload with <code class="content__code">&#60;link rel="preload"&#62;</code>; however, current <a class="content__link" href="http://caniuse.com/#feat=link-rel-preload">Browser support for preload</a> isn't optimal, sitting at just less than 50% (at the time of this writing). So, in about half of our cases, we will have to fetch floral-xsm.png normally - when the client's browser finds it in our CSS.</p>

				<h5 class="content__title">Testing: Preloading vs. Data URI</h5>
				<p class="content__body">To determine which method of delivery we should choose for floral-xsm.png, both methods need to be tested on our pages. The initial results of index.html load with URI are...... TEST.  A quick test run with the preloading approach hints at........ TEST........ <a class="content__link" href="http://caniuse.com/#search=data%20uri">Browser support for Data URIs</a>, with our use case in mind, is just about perfect, and certainly won't be my support bottleneck on this site; so it's safe to say that..........  CONCLUSION.</p>

				<h5 id="whatAboutServerPush" class="content__title">What about Server Push?</h5>
				<p class="content__body">Ultimately, both the URI approach and the preload approach will be left outdated after we're able to excersize <a class="content__link" href="https://hpbn.co/http2/#server-push">Server Push with HTTP/2</a>. Server Push is a way for servers to respond to a single client request, with multiple responses. This is effectively what we are doing by inlining our CSS, JS, and Data URI into index.html - basically telling our users, "here you go, I know you're gonna ask for this anyways". Inlining has it's clear downsides, because we can't cache these files individually and reuse them on other pages. But, it's the reality we live with given our current infrastructure with AWS CloudFront. The support isn't there just yet. Nevertheless, we will still keep our URI/preload approach in our back pocket for clients that don't support HTTP/2, and those clients that have Server Push disabled.</p>

				<h5 class="content__title">Back to floral-crop.png</h5>
				<p class="content__body">When a user of this site lands on index.html, and subsequently clicks on the link that brings them to this page, it would be nice if the image used at the top (floral-crop.png) had already been downloaded by the browser. This would save us a lot of time in rendering the page, and would've been the case when using a single cached image throughout the entire site - instead, we have decided to use seperate image assets that aren't interchangable. This occurance seems like a performance loss, or at least a negative externality of using two modified versions of the same image. However, there is a way we can get the best of both worlds by prefetching floral-crop.png.</p>

				<h5 id="prefetching" class="content__title">Prefetching</h5>
				<p class="content__body"><a class="content__link" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Link_prefetching_FAQ">Link prefetching</a>, similar to preloading <a class="content__link" href="#preloading">(mentioned earlier)</a>, is a feature of modern browsers that uses idle time to fetch and download files that will <i>most likely</i> be needed on subsequest requests. The browser will then store them in the cache for later use. Because prefetching is initiated after page load, it doesn't impact the <a class="content__link" href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/">critical rendering path</a>, which keeps our percieved page loads fast. floral-crop.png is the perfect candidate to be prefetched, mainly because every other page on this site uses it, and it's being <i>assumed</i> that a significant number of visitors will make the navigation to a second page. We don't have the user data to back this up just yet, however, it's what we're rolling with until we do. Because floral-crop.png seems like a good fit to be prefetched, we can apply this mechanism on index.html with...</p> 

<div class="pre__container">
<pre class="pre"><code class="pre__code">&#60;link rel="prefetch" src="images/floral-crop.png"&#62;
</code></pre>
</div>

				<p class="content__body">But of course, there are tradeoffs. The obvious caveat is the extra upfront data transfer costs for both the client and the server. Also, the prefetch resource hint <a class="content__link" href="http://caniuse.com/#feat=link-rel-prefetch">isn't supported</a> in all browsers, so there will be unavoidable instances (notably on iOS and Safari) where clients must wait a little longer for floral-crop.png. While support isn't optimal at the moment, there has be a better (more supported) way we can implement this...</p>

				<h5 id="prefetching" class="content__title">Prefetching w/ Server Push</h5>
				<p class="content__body">Okay, well, this is probably our best option, but again, as I mentioned in <a class="content__link" href="#whatAboutServerPush">What about Server Push?</a>, CloudFront doesn't support Server Push just yet. We <i>would</i> push floral-crop.png down to our client with the request of index.html, and give it a <a class="content__link" href="https://hpbn.co/http2/#stream-prioritization">low stream priority</a> so that it wouldn't be competing for browser resources with our critical assets. Until the support is there, we're going to have to do this another way.</p>

				<h5 id="prefetching" class="content__title">Prefetching w/ JavaScript</h5>
				<p class="content__body">Another way we can handle prefetching floral-crop.png is by way of the JavaScript <code class="content__code">Image()</code> constructor. This constructor will create a new <a class="content__link" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement">HTMLImageElement</a>, and fetch the image we pass to it. If we call the prefetch function after the page has loaded, the image will be fetched and preprocessed without interfering with our critial rendering path.</p>

<div class="pre__container">
<pre class="pre"><code class="pre__code">function prefetch() {
    (new Image()).src = &#39;images/floral-crop.png&#39;;
}
window.onload = prefetch;
</code></pre>
</div>
				
				<p class="content__body">Handling our prefetch this way seems a little hack-ish, and not entirely semantic, but it also gives us the most control over the behaviour of the prefetch. At the same time, it's arguable that we, as developers, shouldn't have this type of unlimited discression. It may be best for us to <a class="content__link" href="https://w3c.github.io/resource-hints/#prefetch">let the browser decide</a> how/when the prefetch occurs (if at all), mainly because it's not an integral function of this site, and the browser definately has a better understanding of the client's resource constraints than we do. For now, we're going to stick with the conservative and less supported approach - the prefetch resource hint. Heck, I don't know if Safari/iOS has plans of supporting the prefetching anytime soon, but if they do, it'll be an automatic win for us.</p>

				<h5 id="prefetching" class="content__title">Prefetching + Service Worker</h5>
				<p class="content__body">Our prefetching method and our Service Worker pair pretty well together - especially because browser support for each aligns nicely. As our resource hint issues a request for floral-crop.png, our service worker sees the request, clones the response, and then adds it to the user's cache. Although we can just explicitly set the Service Worker to cache the floral-crop.png, we'd rather not, due to the reasons stated in the following sections.</p>

				<h5 class="content__title">Art direction</h5>
				<p class="content__body">Regardless of the lean, latency-reducing image delivery methods we decide on, there's a good chance we'll incur at least one more round trip to our server anyways - Why? Because <a class="content__link" href="https://developers.google.com/web/fundamentals/design-and-ui/media/images#art_direction">art direction</a> is important. It's easy to send a small optimized image to our users and call it performant, although doing that doesn't always provide a complete and optimal user experience. Go figure. For one, screen resolution varies wildly between <a class="content__link" href="https://material.io/devices/">all the devices</a> front-end devs have to accomodate nowadays. It's unacceptable to show users with a 3dppx screen (i.e. the Samsung Galaxy S5) an image that was optimized for a 1dppx screen (i.e. my Macbook Air). Blurry images degrade the UX and are no bueno.</p>

				<h5 class="content__title">Low Quality Image Placeholders</h5>
				<p class="content__body">I use our implementation of floral-xsm.png and floral-crop.png as <a class="content__link" href="http://www.guypo.com/introducing-lqip-low-quality-image-placeholders/">low quality image placeholders</a> (or LQIPs), then query the client's device resolution with some javascript (<code class="content__code">window.matchMedia</code>), and go fetch the best image for the user <i>after</i> our lower quality images first load. This means the user gets visual feedback immediatly, <i>then</i> recieve a high-res version to appropiratly compliment their device capabilities. We accomplish this with...</p>



				<h5 class="content__title">Conditional loading with <code class="content__code">srcset</code></h5>
				<p class="content__body">Avatar.png hasn't been talked about much...</p>

				<h5 class="content__title">Conditional loading images for poor connections</h5>
				<p class="content__body">Because mobile networks can vary wildly in bandwidth and latency, partially due to some <a class="content__link" href="https://hpbn.co/assets/diagrams/773ecb15832075c0b56021aa3ad15233.svg">infrastructure overhead</a>, it's also important to consider the network connection and serve appropriate images based on network constraints. However, the <code class="content__code">navigator.connection</code> API is simply too unreliable and <a class="content__link" href="https://developer.mozilla.org/en-US/docs/Web/API/Network_Information_API#Browser_compatibility">unsupported</a> at the moment. For now, we're going to leave this test out of our javascript.</p>




			
				<h5 id="usingWebp" class="content__title">Using Webp</h5>
				<p class="content__body">As it turns out, we can provide even smaller image files with Google's Webp image format... yep, still not done optimizing our images. <a class="content__link" href="https://developers.google.com/speed/webp/">Webp</a> is a relatively new image format, developed by the smart people at over at Google, that provides superior lossy and lossless compression for images on the web. However, the native support for webp (as of this writing) is only in Chrome, Opera, and Andriod Browser, which is around <a class="content__link" href="http://caniuse.com/#feat=webp">73% of the web</a>. But we're going to need 100% of our users to be able to see our images. If we could detect what browser the user was on, and serve them the best image format, that would be ideal. We can do this type of feature detection client-side with a custom <a class="content__link" href="https://modernizr.com/">Modernizr</a> javascript build. If the client's browser supports Webp, Modernizr will be able to detect it, and a "webp" class will be added to the html element. We can check for the presence of the "webp" class in our CSS, and conditionally set different background images (.webp or .png). But there's a performance gotcha when using Modernizr this way - <i>first</i>, the initial response will first be recieved by the user, <i>then</i> the external javascript file will be discovered during parsing, <i>then</i> the browser will have to wait for the javascript file to be fetched, <i>then</i> the javascript will execute and add our "webp" class to the html element, at which point the CSS can <i>finally</i> recognize which image format to go retreive. This approach doesn't seem optimal.<br>

				Alternatively, we could do this with server-side logic, and avoid the extra trips over the network, but we must also consider the additional CPU overhead, setup, and latency. In terms of performance, the CPU overhead and setup are pretty much neglectable, but added latency between Amazon's edge locations and our origin sever has a considerable performance implication - applicable in some cases when providing dynamic content. To simplify things and be decisive, we will just send floral-sm.png with index.html because: 1) we can fetch it right from the get-go with <a class="content__link" href="#preloading">our preload</a>, 2) the browser support for png is ideal, and 3) the difference between floral-sm.png (19.6KB) and floral-sm.webp (16.4KB) is only 3.2KB.<br>

				But hey, we still have floral-cropped.png to think about. The difference between floral-cropped.png (117.2KB) and floral-cropped.webp (88.8KB) is 28.4KB, so the case to serve the image as a Webp is much more compelling. Because we'd like to use Webp, we're going to have to specify the appropriate format of floral-cropped during our prefetch, which means inserting a little javascript logic to handle which file to retreive. I've written a little function that queries the result of our Modernizr script, and injects the proper prefetch request into the document head. It's only 319 bytes, and although this complicates our prefetching process, it's worth the 28.4KB savings.</p>

				<h5 class="content__title">Gulp-imagemin & OptiPNG</h5>
				<p class="content__body">After all of our optimizations, the last attempt at making our images as compact as possible, is to run them through <a class="content__link" href="http://optipng.sourceforge.net/">OptiPNG</a> - a command line "PNG optimizer that recompresses image files to a smaller size, without losing any information". At this point, because all of our images have already been optimized through "save for web" in Photoshop, the additional savings from running OptiPNG's compression on our images folder was limited to XX%, or a measly XXX bytes. However, it's still a good catch to have in a build process. To learn more about how OptiPNG compresses PNGs, <a class="content__link" href="http://optipng.sourceforge.net/optipng-0.7.6.man.pdf">read this</a>. If you'd like more general info on how to optimize PNGs, <a class="content__link" href="http://optipng.sourceforge.net/pngtech/optipng.html">this</a> is a good resource. To make this process streamline with my build process, I incorporated Gulp task <a class="content__link" href="https://www.npmjs.com/package/gulp-imagemin">gulp-imagemin</a>, which actually leverages the OptiPNG compression methods, among others.</p>

				<h5 class="content__title">Our images with JavaScript disabled</h5>
				<p class="content__body">I had noticed in main.css that the classes to style our header looked like <code class="content__code">.webp .header {...}</code> and <code class="content__code">.no-webp .header {...}</code>. I mean, it makes sense because all possible cases are supported, right? Either we support webp, or we don't. Nope. What about the case where our modernizr script never runs, like when JavaScript is disabled, and consequently never applies to the <code class="content__code">.webp</code> and <code class="content__code">.no-webp</code> classes to our <code class="content__code">&#60;html&#62;</code> element? Honestly, I didn't really think about this case until I disabled JavaScript during a test, and the header catostrophically broke - whoops. To fix this, I defined a base <code class="content__code">.header</code> class in our CSS, <i>which I really should've done from the beginning</i>, and then used <code class="content__code">.webp .header {...}</code> and <code class="content__code">.no-webp .header {...}</code> to only apply the fitting <code class="content__code">background-image</code>. But that still left our JavaScript-less users with no image and just a boring <code class="content__code">background-color</code> fallback. Just because they don't have JavaScript enabled, doesn't mean they shouldn't get our sweet floral image. So, I nested our <code class="content__code">&#60;header&#62;</code> inside of a <code class="content__code">&#60;noscript&#62;</code> div with a <code class="content__code">.no-js-header</code> class. That class in our CSS acts as a way for our header to default to our floral-crop.png image with <code class="content__code">.no-js-header .header {...}</code>.</p>
			

			<h3 id="inTheWorks" class="content__heading">In the works</h3>

				<p class="content__body">Over time, I will gradually add components to this site that test design principals and create challenging performance problems. There's so much I'd like to do with this site, and so many cool new toys I want to play around with, but they'll have to come one-at-a-time. For now, this is what's in the pipeline:</p>

				<h5 class="content__title">Service worker</h5>
				<p class="content__body">Device states (low power mode, device overheating, memory constraints, etc.) and netowrks (especially mobile networks) are unpredictable. This unpredictability means that fast isn't always enough. Our applications must be resilient. Offline first, bro</p>

				<h5 class="content__title">Server Push - HTTP/2</h5>
				<p class="content__body">I'd love to figure out how to implement <a class="content__link" href="https://http2.github.io/faq/#how-can-i-use-http2-server-push">Server Push</a> with CloudFront so I can play around with it, but it's not availbale with cloudfront.</p>

				<h5 class="content__title">Contact form</h5>
				<p class="content__body">I've implemented contact forms before, specifically <a class="content__link" href="https://formspree.io/">formspree.io</a>, that are incredibly easy and free to integrate into a static webpage (not an endorsement); however, I'd consider it a low priority relative to everything else I'd like to do on this site. Nevertheless, there is one strong case to implement a contact form sooner than later - the emailto link behavior is pretty unpredictable, and can be annoying. I had a buddy look at my site, and he tested the "email me" button on index.html, and it opened his default email client on his Macbook... you know, the one nobody uses. It was this exact pain that drove me to customize my mailto behavior in Chrome to open Gmail in a browser window. It escaped me that not everybody customizes this behavior within their browsers, and still deal with this. But on the other hand, if <a class="content__link" href="https://jakearchibald.com/">Jake Archibold</a> is using the mailto method (on the sidebar), then it should be good enough for me - for now, at least.</p>

		</article>

	</main>

	<footer class="footer">
		<div class="footer__contain">
			<div class="footer__contain--left">
				<a href="index.html" class="footer__link">HOME</a>
				<a href="design.html" class="footer__link">DESIGN</a>
				<a href="resume.html" class="footer__link">RESUME</a>
			</div>
			<div class="footer__contain--right">
				<span class="footer__blurb">made with <span class="footer__pseudoCode">code</span> by</span>
				<span class="footer__blurb--sm">...made by</span>
				<img class="footer__avatar" src="images/avatar-1x.png" srcset="images/avatar-2x.png 2x, images/avatar-3x.png 3x">
			</div>
		</div>
	</footer>

</body>
</html>